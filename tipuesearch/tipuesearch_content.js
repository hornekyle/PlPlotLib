var tipuesearch = {"pages":[{"text":"PlPlotLib PlPlotLib is a wrapper for PlPlot inspired by the interface of \nmatplotlib. It is intended to fill the need for rapid feedback while \ndeveloping numerical simulations, and does not replace more \nsophisticated packages such as\nmatplotlib or even direct use of PlPlot. While it is possible that the output from PlPlotLib may be considered \nas publication quality, no assertion is made along those lines. This \nsoftware has been written in the hope that it will be useful, \nespecially for students in numerical analysis courses based on Fortran. Developer Info Dr Kyle Horne Assistant Professor\nMechanical and Energy Engineering\nUniversity of North Texas","tags":"","loc":"index.html","title":" PlPlotLib "},{"text":"Source Code module utilities_mod !! Utility module containing miscellaneous tools that don't !! quite fit anywhere else. use iso_fortran_env use kinds_mod implicit none private integer , parameter :: stdin = INPUT_UNIT integer , parameter :: stdout = OUTPUT_UNIT interface mixval !! Return a 2-vector comprising the minimum and maximum values of an array module procedure mixval_1 module procedure mixval_2 module procedure mixval_3 end interface interface span !! Return a the maximum-minumum values of an array module procedure span_1 module procedure span_2 module procedure span_3 end interface interface flatten !! Reduce an array to one dimension module procedure flatten_2 module procedure flatten_3 end interface public :: stdin public :: stdout public :: mixval public :: span public :: linspace public :: startsWith public :: endsWith public :: meshGridX public :: meshGridY public :: randomNormal public :: randomUniform public :: mean public :: stdev public :: flatten public :: colorize public :: int2char public :: real2char public :: showProgress contains function mixval_1 ( x ) result ( b ) !! Return [hi,low] for an array real ( wp ), dimension (:), intent ( in ) :: x !! Array to find extrema in real ( wp ), dimension ( 2 ) :: b b = [ minval ( x ), maxval ( x )] end function mixval_1 function mixval_2 ( x ) result ( b ) !! Return [hi,low] for an array real ( wp ), dimension (:,:), intent ( in ) :: x !! Array to find extrema in real ( wp ), dimension ( 2 ) :: b b = [ minval ( x ), maxval ( x )] end function mixval_2 function mixval_3 ( x ) result ( b ) !! Return [hi,low] for an array real ( wp ), dimension (:,:,:), intent ( in ) :: x !! Array to find extrema in real ( wp ), dimension ( 2 ) :: b b = [ minval ( x ), maxval ( x )] end function mixval_3 function span_1 ( x ) result ( o ) !! Return hi-low for an array real ( wp ), dimension (:), intent ( in ) :: x !! Array to find span in real ( wp ) :: o o = maxval ( x ) - minval ( x ) end function span_1 function span_2 ( x ) result ( o ) !! Return hi-low for an array real ( wp ), dimension (:,:), intent ( in ) :: x !! Array to find span in real ( wp ) :: o o = maxval ( x ) - minval ( x ) end function span_2 function span_3 ( x ) result ( o ) !! Return hi-low for an array real ( wp ), dimension (:,:,:), intent ( in ) :: x !! Array to find span in real ( wp ) :: o o = maxval ( x ) - minval ( x ) end function span_3 function linspace ( l , h , N ) result ( o ) !! Return an array of evenly-spaced values real ( wp ), intent ( in ) :: l !! Low-bound for values real ( wp ), intent ( in ) :: h !! High-bound for values integer , intent ( in ), optional :: N !! Number of values (default 20) real ( wp ), dimension (:), allocatable :: o integer :: Nl , i Nl = 20 if ( present ( N )) Nl = N o = [( ( h - l ) * real ( i - 1 , wp ) / real ( Nl - 1 , wp ) + l , i = 1 , Nl )] end function linspace function startsWith ( text , str ) result ( o ) !! Test if text starts with str character ( * ), intent ( in ) :: text !! Text to search character ( * ), intent ( in ) :: str !! String to look for logical :: o integer :: k k = len ( str ) o = text ( 1 : k ) == str end function startsWith function endsWith ( text , str ) result ( o ) !! Test if text ends with str character ( * ), intent ( in ) :: text !! Text to search character ( * ), intent ( in ) :: str !! String to look for logical :: o integer :: k k = len ( text ) o = text ( k - len ( str ) + 1 : k ) == str end function endsWith function randomNormal () result ( o ) !! Return a sample from an approximate normal distribution !! with a mean of \\mu=0 and a standard deviation of !! \\sigma=1. In this approximate distribution, x\\in[-6,6]. real ( wp ) :: o real ( wp ), dimension ( 12 ) :: x call random_number ( x ) o = sum ( x ) - 6.0_wp end function randomNormal function randomUniform () result ( o ) !! Return a sample from a uniform distribution !! in the range x\\in[-1,1]. real ( wp ) :: o call random_number ( o ) o = o * 2.0_wp - 1.0_wp end function randomUniform function flatten_2 ( A ) result ( o ) !! Convert a 2d array to 1d real ( wp ), dimension (:,:), intent ( in ) :: A !! Array to convert real ( wp ), dimension (:), allocatable :: o o = reshape ( A ,[ size ( A )]) end function flatten_2 function flatten_3 ( A ) result ( o ) !! Convert a 3d array to 1d real ( wp ), dimension (:,:,:), intent ( in ) :: A !! Array to convert real ( wp ), dimension (:), allocatable :: o o = reshape ( A ,[ size ( A )]) end function flatten_3 function meshGridX ( x , y ) result ( o ) !! Construct a 2d array of X values from a structured grid real ( wp ), dimension (:), intent ( in ) :: x !! x-positions in grid real ( wp ), dimension (:), intent ( in ) :: y !! y-positions in grid real ( wp ), dimension (:,:), allocatable :: o integer :: Nx , Ny integer :: i , j Nx = size ( x ) Ny = size ( y ) allocate ( o ( Nx , Ny )) forall ( i = 1 : Nx , j = 1 : Ny ) o ( i , j ) = x ( i ) end function meshGridX function meshGridY ( x , y ) result ( o ) !! Construct a 2d array of Y values from a structured grid real ( wp ), dimension (:), intent ( in ) :: x !! x-positions in grid real ( wp ), dimension (:), intent ( in ) :: y !! y-positions in grid real ( wp ), dimension (:,:), allocatable :: o integer :: Nx , Ny integer :: i , j Nx = size ( x ) Ny = size ( y ) allocate ( o ( Nx , Ny )) forall ( i = 1 : Nx , j = 1 : Ny ) o ( i , j ) = y ( j ) end function meshGridY function colorize ( s , c ) result ( o ) !! Add terminal format codes to coloize a string character ( * ), intent ( in ) :: s !! String to colorize integer , dimension ( 3 ) :: c ! c in [0,5] !! Color code in [r,g,b] where r,g,b\\in[0,5] character (:), allocatable :: o character ( 1 ), parameter :: CR = achar ( 13 ) character ( 1 ), parameter :: ESC = achar ( 27 ) character ( 20 ) :: pre character ( 3 ) :: cb write ( cb , '(1I3)' ) 36 * c ( 1 ) + 6 * c ( 2 ) + c ( 3 ) + 16 pre = ESC // '[38;5;' // trim ( adjustl ( cb )) // 'm' o = trim ( pre ) // s // ESC // '[0m' end function colorize elemental function real2char ( a , f , l ) result ( o ) !! Convert a real to a character real ( wp ), intent ( in ) :: a !! Real value to convert character ( * ), optional , intent ( in ) :: f !! Format of result integer , optional , intent ( in ) :: l !! Length of result character (:), allocatable :: o character ( 128 ) :: buf if ( present ( l )) then allocate ( character ( l ) :: o ) if ( present ( f )) then write ( o , '(' // f // ')' ) a else write ( o , * ) a end if else if ( present ( f )) then write ( buf , '(' // f // ')' ) a else write ( buf , * ) a end if o = trim ( adjustl ( buf )) end if end function real2char elemental function int2char ( a , f , l ) result ( o ) !! Convert an integer to a character integer , intent ( in ) :: a !! Integer value to convert character ( * ), optional , intent ( in ) :: f !! Format of result integer , optional , intent ( in ) :: l !! Length of result character (:), allocatable :: o character ( 128 ) :: buf if ( present ( l )) then allocate ( character ( l ) :: o ) if ( present ( f )) then write ( o , '(' // f // ')' ) a else write ( o , * ) a end if else if ( present ( f )) then write ( buf , '(' // f // ')' ) a else write ( buf , * ) a end if o = trim ( adjustl ( buf )) end if end function int2char subroutine showProgress ( m , p ) !! Show a progress bar with a message character ( * ), intent ( in ) :: m !! Message to show real ( wp ), intent ( in ) :: p !! Progress level p\\in[0,1] real ( wp ) :: r real ( wp ), save :: po integer :: N , k N = 40 if ( p <= 0.0_wp ) then po = p end if if ( p - po < 0.05 . and . p < 1.0_wp ) then return else po = p end if write ( stdout , '(1A)' , advance = 'no' ) achar ( 13 ) // colorize ( m // ' [' ,[ 5 , 5 , 0 ]) do k = 1 , N r = real ( k - 1 , wp ) / real ( N - 1 , wp ) if ( r <= p ) then write ( stdout , '(1A)' , advance = 'no' ) colorize ( '=' , cmap ( r ,[ 0.0_wp , 1.0_wp ])) else write ( stdout , '(1A)' , advance = 'no' ) colorize ( ' ' ,[ 0 , 0 , 0 ]) end if end do write ( stdout , '(1A,1A,1X,1A)' , advance = 'no' ) colorize ( '] ' ,[ 5 , 5 , 0 ]), & & colorize ( real2char ( 10 0.0_wp * p , '1F5.1' ), cmap ( p ,[ 0.0_wp , 1.0_wp ])), & & colorize ( '%' ,[ 5 , 5 , 0 ]) if ( p >= 1.0_wp ) write ( stdout , '(1A)' ) '' flush ( stdout ) end subroutine showProgress function cmap ( v , r ) result ( c ) !! Sample a color from a cool-warm colormap for colorize real ( wp ), intent ( in ) :: v !! Value to sample real ( wp ), dimension ( 2 ), intent ( in ) :: r !! Range to sample from integer , dimension ( 3 ) :: c integer :: s if ( v < sum ( r ) / 2.0_wp ) then s = nint (( v - r ( 1 )) / ( sum ( r ) / 2.0_wp - r ( 1 )) * 5.0_wp ) c = [ s , s , 5 ] else s = 5 - nint (( v - sum ( r ) / 2.0_wp ) / ( r ( 2 ) - sum ( r ) / 2.0_wp ) * 5.0_wp ) c = [ 5 , s , s ] end if end function cmap function mean ( d ) result ( o ) !! Compute the arithmetic mean of an array real ( wp ), dimension (:), intent ( in ) :: d real ( wp ) :: o o = sum ( d ) / real ( size ( d ), wp ) end function mean function stdev ( d ) result ( o ) !! Compute the standard deviation of an array real ( wp ), dimension (:), intent ( in ) :: d real ( wp ) :: o o = sqrt ( sum (( d - mean ( d )) ** 2 ) / real ( size ( d ) - 1 , wp )) end function stdev end module utilities_mod","tags":"","loc":"sourcefile/utilities.f90.html","title":"utilities.f90 – PlPlotLib"},{"text":"Source Code module plplotlib_mod !! Wrapper module for plplot to give it a more matplotlib like personality use kinds_mod , only : wp use plplot use utilities_mod implicit none private integer , parameter :: pp = plflt integer , parameter :: pi = kind ( 1 ) character ( * ), parameter :: default_dev = 'qtwidget' !! Default output device !=================! != Library State =! !=================! logical :: didShow = . false . !! Flag for library display status real ( pp ) :: fontScale = 1.0_pp !! Font scale factor to resetPen logical :: blackOnWhite = . true . !! Reverse black and white logical :: transparentBackground = . false . !! Transparent background !==============! != Interfaces =! !==============! interface localize module procedure localize_1 module procedure localize_2 end interface !===========! != Exports =! !===========! public :: setup , show public :: figure public :: subplot public :: xylim , xlim , ylim , xyzlim public :: labels , xlabel , ylabel , title public :: ticks , xticks , yticks , box public :: legend public :: mixval , linspace , binData public :: plot , plot3 public :: scatter , errorbar public :: contour , contourf public :: colorbar , colorbar2 public :: bar , barh public :: hist public :: fillBetween , fillBetweenx public :: quiver public :: surface , wireframe contains !===================! != Helper Routines =! !===================! function binData ( d , N , db , normalize ) result ( o ) !! Count data in each bin real ( wp ), dimension (:), intent ( in ) :: d !! Data for binning integer , intent ( in ), optional :: N !! Number of bins real ( wp ), dimension ( 2 ), intent ( in ), optional :: db !! Boundaries of bin range integer , intent ( in ), optional :: normalize !! Normalization type (1=sum, 2=bin size, 3=maxval) real ( wp ), dimension (:,:), allocatable :: o real ( wp ), dimension (:), allocatable :: b integer :: Nl , k Nl = 10 if ( present ( N )) Nl = N if ( present ( db )) then b = linspace ( db ( 1 ), db ( 2 ), Nl + 1 ) else b = linspace ( minval ( d ) - epsilon ( 1.0_wp ), maxval ( d ) + epsilon ( 1.0_wp ), Nl + 1 ) end if allocate ( o ( Nl , 2 )) o (:, 1 ) = ( b ( 1 : Nl ) + b ( 2 : Nl + 1 )) / 2.0_wp do k = 1 , Nl o ( k , 2 ) = real ( count ( d >= b ( k ) . and . d <= b ( k + 1 )), wp ) end do if ( present ( normalize )) then select case ( normalize ) case ( 1 ) o (:, 2 ) = o (:, 2 ) / sum ( o (:, 2 )) case ( 2 ) do k = 1 , Nl o ( k , 2 ) = o ( k , 2 ) / ( b ( k + 1 ) - b ( k )) end do case ( 3 ) o (:, 2 ) = o (:, 2 ) / maxval ( o (:, 2 )) end select end if end function binData function localize_1 ( A ) result ( o ) real ( wp ), dimension (:), intent ( in ) :: A real ( pp ), dimension (:), allocatable :: o integer :: N , k N = size ( A ) allocate ( o ( N )) forall ( k = 1 : N ) o ( k ) = real ( A ( k ), pp ) end function localize_1 function localize_2 ( A ) result ( o ) real ( wp ), dimension (:,:), intent ( in ) :: A real ( pp ), dimension (:,:), allocatable :: o integer :: N , M , i , j N = size ( A , 1 ) M = size ( A , 2 ) allocate ( o ( N , M )) forall ( i = 1 : N , j = 1 : M ) o ( i , j ) = real ( A ( i , j ), pp ) end function localize_2 !============================! != Axes and Figure Routines =! !============================! subroutine figure !! Create a new figure logical , save :: isFirst = . true . if (. not . isFirst ) then call pleop () else isFirst = . false . end if call plbop () call plssub ( 1 , 1 ) call pladv ( 1 ) call resetPen () end subroutine figure subroutine subplot ( ny , nx , i , aspect , is3d ) !! Create a set of axes on a figure integer , intent ( in ) :: nx !! Number of subplot columns integer , intent ( in ) :: ny !! Number of subplot rows integer , intent ( in ) :: i !! Subplot to use real ( wp ), intent ( in ), optional :: aspect !! Aspect ratio of the axes logical , intent ( in ), optional :: is3d logical :: is3dl call plssub ( nx , ny ) call pladv ( i ) call resetPen () is3dl = . false . if ( present ( is3d )) is3dl = is3d if ( is3dl ) then call plvpor ( 0.0_pp , 1.0_pp , 0.0_pp , 1.0_pp ) else if ( present ( aspect )) then call plvasp ( real ( aspect , pp )) else call plvsta () end if end if call defaultLim () end subroutine subplot subroutine defaultLim real ( pp ), parameter :: eps = epsilon ( 1.0_pp ) call plwind ( - eps , eps , - eps , eps ) end subroutine defaultLim subroutine xylim ( xb , yb ) !! Set the x and y ranges of the plot real ( wp ), dimension ( 2 ), intent ( in ) :: xb !! x-range of plot real ( wp ), dimension ( 2 ), intent ( in ) :: yb !! y-range of plot real ( pp ), dimension ( 2 ) :: xbl , ybl xbl = localize ( xb ) ybl = localize ( yb ) call plwind ( xbl ( 1 ), xbl ( 2 ), ybl ( 1 ), ybl ( 2 )) end subroutine xylim subroutine xlim ( xl , xh ) !! Set the limits of the x-axis real ( wp ), intent ( in ) :: xl , xh real ( pp ) :: x1 , x2 , y1 , y2 call plgvpw ( x1 , x2 , y1 , y2 ) call plwind ( real ( xl , pp ), real ( xh , pp ), y1 , y2 ) end subroutine xlim subroutine ylim ( yl , yh ) !! Set the limits of the y-axis real ( wp ), intent ( in ) :: yl , yh real ( pp ) :: x1 , x2 , y1 , y2 call plgvpw ( x1 , x2 , y1 , y2 ) call plwind ( x1 , x2 , real ( yl , pp ), real ( yh , pp )) end subroutine ylim subroutine xyzlim ( xb , yb , zb , altitude , azimuth , zoom ) !! Set the limits for a 3d plot real ( wp ), dimension ( 2 ), intent ( in ) :: xb !! x-range of plot real ( wp ), dimension ( 2 ), intent ( in ) :: yb !! y-range of plot real ( wp ), dimension ( 2 ), intent ( in ) :: zb !! z-range of plot real ( wp ), intent ( in ), optional :: altitude !! Altitude angle of plot in degrees real ( wp ), intent ( in ), optional :: azimuth !! Azimuth angle of plot in degrees real ( wp ), intent ( in ), optional :: zoom !! Zoom ratio (default 1.0) real ( pp ) :: al , az , zm al = 4 5.0_pp if ( present ( altitude )) al = real ( altitude , pp ) az = 6 0.0_pp if ( present ( azimuth )) az = real ( azimuth , pp ) zm = 1.0_pp if ( present ( zoom )) zm = real ( zoom , pp ) call plwind ( - 1.0_pp , 1.0_pp , - 1.0_pp , 1.5_pp ) call plw3d ( zm , zm , 1.2_pp * zm , & & real ( xb ( 1 ), pp ), real ( xb ( 2 ), pp ), & & real ( yb ( 1 ), pp ), real ( yb ( 2 ), pp ), & & real ( zb ( 1 ), pp ), real ( zb ( 2 ), pp ), al , az ) end subroutine xyzlim subroutine ticks ( dx , dy , logx , logy , color , lineWidth ) !! Set the ticks for the axes real ( wp ), intent ( in ), optional :: dx !! Spacing between ticks on x-axis real ( wp ), intent ( in ), optional :: dy !! Spacing between ticks on y-axis logical , intent ( in ), optional :: logx !! Flag for log-ticks and labels on x-axis logical , intent ( in ), optional :: logy !! Flag for log-ticks and labels on y-axis character ( * ), intent ( in ), optional :: color !! Color code for ticks, box, and labels real ( wp ), optional :: linewidth !! Line width for ticks and box real ( pp ) :: dxl , dyl character ( 10 ) :: xopts , yopts dxl = 0.0_pp if ( present ( dx )) dxl = real ( dx , pp ) dyl = 0.0_pp if ( present ( dy )) dyl = real ( dy , pp ) xopts = 'bcnst' if ( present ( logx )) then if ( logx ) xopts = 'bcnstl' end if yopts = 'bcnstv' if ( present ( logy )) then if ( logy ) yopts = 'bcnstvl' end if call resetPen () if ( present ( color )) call setColor ( color ) if ( present ( lineWidth )) call setLineWidth ( lineWidth ) call plbox ( xopts , dxl , 0 , yopts , dyl , 0 ) call resetPen () end subroutine ticks subroutine box ( xLabel , yLabel , zLabel , color ) !! Set x,y and plot labels character ( * ), intent ( in ) :: xLabel !! Label for x-axis character ( * ), intent ( in ) :: yLabel !! Label for x-axis character ( * ), intent ( in ) :: zLabel !! Label for z-axis character ( * ), intent ( in ), optional :: color !! Color of labels if ( present ( color )) call setColor ( color ) call plbox3 ( 'bnstu' , xLabel , 0.0_pp , 0 , 'bnstu' , yLabel , 0.0_pp , 0 , 'bnstu' , zLabel , 0.0_pp , 0 ) call resetPen () end subroutine box subroutine xticks ( d , logScale , primary , secondary , color , lineWidth ) !! Set the ticks for the x-axis real ( wp ), intent ( in ), optional :: d !! Spacing between ticks logical , intent ( in ), optional :: logScale !! Flag for log-ticks and labels logical , intent ( in ), optional :: primary !! Draw primary axis logical , intent ( in ), optional :: secondary !! Draw secondary axis character ( * ), intent ( in ), optional :: color !! Color code for ticks, box, and labels real ( wp ), optional :: linewidth !! Line width for ticks and box real ( pp ) :: dxl , dyl character ( 10 ) :: xopts , yopts dxl = 0.0_pp dyl = 0.0_pp if ( present ( d )) dxl = real ( d , pp ) xopts = 'nst' if ( present ( primary )) then if ( primary ) xopts = trim ( xopts ) // 'b' else xopts = trim ( xopts ) // 'b' end if if ( present ( secondary )) then if ( secondary ) xopts = trim ( xopts ) // 'c' else xopts = trim ( xopts ) // 'c' end if if ( present ( logScale )) then if ( logScale ) xopts = trim ( xopts ) // 'l' end if yopts = '' if ( present ( color )) call setColor ( color ) if ( present ( lineWidth )) call setLineWidth ( lineWidth ) call plbox ( xopts , dxl , 0 , yopts , dyl , 0 ) call resetPen () end subroutine xticks subroutine yticks ( d , logScale , primary , secondary , color , lineWidth ) !! Set the ticks for the y-axis real ( wp ), intent ( in ), optional :: d !! Spacing between ticks logical , intent ( in ), optional :: logScale !! Flag for log-ticks and labels logical , intent ( in ), optional :: primary !! Draw primary axis logical , intent ( in ), optional :: secondary !! Draw secondary axis character ( * ), intent ( in ), optional :: color !! Color code for ticks, box, and labels real ( wp ), optional :: linewidth !! Line width for ticks and box real ( pp ) :: dxl , dyl character ( 10 ) :: xopts , yopts dxl = 0.0_pp dyl = 0.0_pp if ( present ( d )) dyl = real ( d , pp ) yopts = 'nst' if ( present ( primary )) then if ( primary ) yopts = trim ( xopts ) // 'b' else yopts = trim ( yopts ) // 'b' end if if ( present ( secondary )) then if ( secondary ) yopts = trim ( yopts ) // 'c' else yopts = trim ( yopts ) // 'c' end if if ( present ( logScale )) then if ( logScale ) yopts = trim ( yopts ) // 'l' end if xopts = '' if ( present ( color )) call setColor ( color ) if ( present ( lineWidth )) call setLineWidth ( lineWidth ) call plbox ( xopts , dxl , 0 , yopts , dyl , 0 ) call resetPen () end subroutine yticks subroutine labels ( xLabel , yLabel , plotLabel , color ) !! Set x,y and plot labels character ( * ), intent ( in ) :: xLabel !! Label for x-axis character ( * ), intent ( in ) :: yLabel !! Label for x-axis character ( * ), intent ( in ) :: plotLabel !! Label entire plot character ( * ), intent ( in ), optional :: color !! Color of labels if ( present ( color )) call setColor ( color ) call pllab ( xLabel , yLabel , plotLabel ) call resetPen () end subroutine labels subroutine xlabel ( label , color ) !! Set x-label character ( * ), intent ( in ) :: label !! Label for axis character ( * ), intent ( in ), optional :: color !! Color of labels if ( present ( color )) call setColor ( color ) call plmtex ( 'b' , 3.0_pp , 0.5_pp , 0.5_pp , label ) call resetPen () end subroutine xlabel subroutine ylabel ( label , color ) !! Set y-label character ( * ), intent ( in ) :: label !! Label for axis character ( * ), intent ( in ), optional :: color !! Color of labels if ( present ( color )) call setColor ( color ) call plmtex ( 'l' , 5.0_pp , 0.5_pp , 0.5_pp , label ) call resetPen () end subroutine ylabel subroutine title ( label , color ) !! Set plot title character ( * ), intent ( in ) :: label !! Label for plot character ( * ), intent ( in ), optional :: color !! Color of labels if ( present ( color )) call setColor ( color ) call plmtex ( 't' , 1.5_pp , 0.5_pp , 0.5_pp , label ) call resetPen () end subroutine title subroutine colorbar ( z , N , leftLabel , rightLabel ) !! Add a colorbar to the top of the plot real ( wp ), dimension (:,:), intent ( in ) :: z !! Data used for levels computation integer , intent ( in ) :: N !! Number of levels to compute character ( * ), intent ( in ), optional :: leftLabel !! Label for left side of colorbar character ( * ), intent ( in ), optional :: rightLabel !! Label for right side of colorbar real ( pp ), dimension (:,:), allocatable :: values character ( 64 ), dimension ( 2 ) :: labels real ( pp ) :: fill_width real ( pp ) :: cont_width integer :: cont_color real ( pp ) :: colorbar_width real ( pp ) :: colorbar_height integer :: k values = reshape ( & & real ([( real ( k - 1 , wp ) / real ( N - 1 , wp ) * ( maxval ( z ) - minval ( z )) + minval ( z ) , k = 1 , N )], pp ), & & [ N , 1 ]) fill_width = 2.0_pp cont_width = 0.0_pp cont_color = 1 labels = '' if ( present ( leftLabel )) labels ( 1 ) = leftLabel if ( present ( rightLabel )) labels ( 2 ) = rightLabel call plcolorbar ( colorbar_width , colorbar_height ,& & ior ( PL_COLORBAR_GRADIENT , PL_COLORBAR_SHADE_LABEL ), PL_POSITION_TOP ,& & 0.0_pp , 0.01_pp , 0.75_pp , 0.05_pp ,& & 0 , 1 , 1 , 0.0_pp , 0.0_pp , & & cont_color , cont_width , & & [ PL_COLORBAR_LABEL_LEFT , PL_COLORBAR_LABEL_RIGHT ], labels , & & [ 'bcvmt' ],[ 0.0_pp ],[ 0 ],[ size ( values )], values ) end subroutine colorbar subroutine colorbar2 ( z , N , leftLabel , rightLabel ) !! Add a colorbar to the top of the plot real ( wp ), dimension (:,:), intent ( in ) :: z !! Data used for levels computation integer , intent ( in ) :: N !! Number of levels to compute character ( * ), intent ( in ), optional :: leftLabel !! Label for left side of colorbar character ( * ), intent ( in ), optional :: rightLabel !! Label for right side of colorbar real ( pp ), dimension (:,:), allocatable :: values character ( 64 ), dimension ( 2 ) :: labels real ( pp ) :: fill_width real ( pp ) :: cont_width integer :: cont_color real ( pp ) :: colorbar_width real ( pp ) :: colorbar_height integer :: k values = reshape ( & & real ([( real ( k - 1 , wp ) / real ( N - 1 , wp ) * ( maxval ( z ) - minval ( z )) + minval ( z ) , k = 1 , N )], pp ), & & [ N , 1 ]) fill_width = 2.0_pp cont_width = 0.0_pp cont_color = 1 labels = '' if ( present ( leftLabel )) labels ( 1 ) = leftLabel if ( present ( rightLabel )) labels ( 2 ) = rightLabel call plcolorbar ( colorbar_width , colorbar_height ,& & ior ( PL_COLORBAR_GRADIENT , PL_COLORBAR_SHADE_LABEL ), PL_POSITION_RIGHT ,& & 0.01_pp , 0.0_pp , 0.05_pp , 0.75_pp ,& & 0 , 1 , 1 , 0.0_pp , 0.0_pp , & & cont_color , cont_width , & & [ PL_COLORBAR_LABEL_BOTTOM , PL_COLORBAR_LABEL_TOP ], labels , & & [ 'bcvmt' ],[ 0.0_pp ],[ 0 ],[ size ( values )], values ) end subroutine colorbar2 subroutine legend ( corner , series , lineWidths , markScales , markCounts , ncol ) !! Create legend for plot data !! !! FIXME: Text sizing should be modifiable character ( * ), intent ( in ) :: corner !! Corner for legend character ( * ), dimension (:,:), intent ( in ) :: series !! Data series in rows !! [name,textColor,lineStyle,lineColor,markStyle,markColor,boxColor] real ( wp ), dimension (:), intent ( in ), optional :: lineWidths !! Line widths for the plots real ( wp ), dimension (:), intent ( in ), optional :: markScales !! Marker sizes for the plots integer , dimension (:), intent ( in ), optional :: markCounts !! Marker counts for the plots integer , intent ( in ), optional :: ncol !! Number of columns real ( pp ) :: width , height , xoff , yoff real ( pp ) :: plotWidth integer :: opt , cornerl integer :: bg_color , bb_color , bb_style , lncol , lnrow integer , dimension ( size ( series , 1 )) :: opts real ( pp ), dimension ( size ( series , 1 )) :: lwidths , mscales integer , dimension ( size ( series , 1 )) :: mcounts , text_colors real ( pp ) :: text_offset , text_scale , text_spacing , text_justification integer , dimension ( size ( series , 1 )) :: box_colors , box_patterns real ( pp ), dimension ( size ( series , 1 )) :: box_scales , box_line_widths integer , dimension ( size ( series , 1 )) :: line_colors , line_styles integer , dimension ( size ( series , 1 )) :: mark_colors character ( 64 ), dimension ( size ( series , 1 )) :: mark_styles integer :: k call doLegendBox () opts = 0 do k = 1 , size ( series , 1 ) if ( series ( k , 3 ) /= '' ) opts ( k ) = ior ( opts ( k ), PL_LEGEND_LINE ) if ( series ( k , 5 ) /= '' ) opts ( k ) = ior ( opts ( k ), PL_LEGEND_SYMBOL ) if ( series ( k , 7 ) /= '' ) opts ( k ) = ior ( opts ( k ), PL_LEGEND_COLOR_BOX ) end do call doText () call doBoxes () call doLines () call doMarkers () call pllegend ( width , height , opt , cornerl , xoff , yoff , plotWidth , & & bg_color , bb_color , bb_style , & & lnrow , lncol , size ( series , 1 ), opts , text_offset , & & text_scale , text_spacing , text_justification , text_colors , series (:, 1 ), & & box_colors , box_patterns , box_scales , box_line_widths , & & line_colors , line_styles , lwidths , & & mark_colors , mscales , mcounts , mark_styles ) contains subroutine doLegendBox opt = PL_LEGEND_BACKGROUND + PL_LEGEND_BOUNDING_BOX cornerl = getCorner ( corner ) xoff = 0.0_pp yoff = 0.0_pp plotWidth = 0.05_pp bg_color = 0 bb_color = 1 bb_style = getLineStyleCode ( '-' ) lncol = 1 if ( present ( ncol )) lncol = ncol lnrow = size ( series , 1 ) / lncol end subroutine doLegendBox subroutine doText text_offset = 0.3_pp text_scale = fontScale text_spacing = 3.0_pp text_justification = 0.0_pp do k = 1 , size ( series , 1 ) text_colors = getColorCode ( series ( k , 2 )) end do end subroutine doText subroutine doBoxes do k = 1 , size ( series , 1 ) box_colors ( k ) = getColorCode ( series ( k , 7 )) end do box_patterns = 0 box_scales = 0.5_pp box_line_widths = 0.0_pp end subroutine doBoxes subroutine doLines lwidths = 1.0_pp if ( present ( lineWidths )) lwidths = real ( lineWidths , pp ) do k = 1 , size ( series , 1 ) line_colors ( k ) = getColorCode ( series ( k , 4 )) line_styles ( k ) = getLineStyleCode ( series ( k , 3 )) end do end subroutine doLines subroutine doMarkers mcounts = 2 if ( present ( markCounts )) mcounts = markCounts mscales = 1.0_pp if ( present ( markScales )) mscales = real ( markScales , pp ) do k = 1 , size ( series , 1 ) mark_colors ( k ) = getColorCode ( series ( k , 6 )) mark_styles ( k ) = getSymbolCode ( series ( k , 5 )) end do end subroutine doMarkers function getCorner ( text ) result ( code ) character ( * ), intent ( in ) :: text integer :: code code = PL_POSITION_INSIDE if ( startsWith ( text , 'upper' ) ) code = code + PL_POSITION_TOP if ( startsWith ( text , 'lower' ) ) code = code + PL_POSITION_BOTTOM if ( endsWith ( text , 'right' ) ) code = code + PL_POSITION_RIGHT if ( endsWith ( text , 'left' ) ) code = code + PL_POSITION_LEFT end function getCorner end subroutine legend !=====================! != Plotting Routines =! !=====================! subroutine hist ( d , N , db , relWidth , fillColor , fillPattern , lineColor , lineWidth ) !! Create a histogram real ( wp ), dimension (:), intent ( in ) :: d !! Data for binning integer , intent ( in ), optional :: N !! Number of bins real ( wp ), dimension ( 2 ), intent ( in ), optional :: db !! Boundaries of bin range real ( wp ), intent ( in ), optional :: relWidth !! Relative width of bars (default 0.8) character ( * ), intent ( in ), optional :: fillColor !! Color of bar fills character ( * ), intent ( in ), optional :: fillPattern !! Pattern of bar fills character ( * ), intent ( in ), optional :: lineColor !! Color of lines around bars real ( wp ), optional :: lineWidth !! Width of lines around bars real ( wp ), dimension (:,:), allocatable :: h real ( wp ), dimension ( 2 ) :: dbl integer :: Nl real ( wp ) :: relWidthl real ( wp ) :: lineWidthl Nl = 20 if ( present ( N )) Nl = N if ( present ( db )) then dbl = db else dbl = mixval ( d ) + [ - 1.0_wp , 1.0_wp ] * epsilon ( 1.0_wp ) end if h = binData ( d , Nl , dbl , normalize = 3 ) relWidthl = 1.0_wp if ( present ( relWidth )) relWidthl = relWidth lineWidthl = 0.5_wp if ( present ( lineWidth )) lineWidthl = lineWidth if ( present ( lineColor )) then if ( present ( fillColor )) then if ( present ( fillPattern )) then call bar ( h (:, 1 ), h (:, 2 ), relWidth = relWidthl , lineColor = lineColor , lineWidth = lineWidthl , & & fillColor = fillColor , fillPattern = fillPattern ) else call bar ( h (:, 1 ), h (:, 2 ), relWidth = relWidthl , lineColor = lineColor , lineWidth = lineWidthl , & & fillColor = fillColor ) end if else if ( present ( fillPattern )) then call bar ( h (:, 1 ), h (:, 2 ), h (:, 2 ), relWidth = relWidthl , lineColor = lineColor , lineWidth = lineWidthl , & & fillPattern = fillPattern ) else call bar ( h (:, 1 ), h (:, 2 ), h (:, 2 ), relWidth = relWidthl , lineColor = lineColor , lineWidth = lineWidthl ) end if end if else if ( present ( fillColor )) then if ( present ( fillPattern )) then call bar ( h (:, 1 ), h (:, 2 ), relWidth = relWidthl , lineWidth = lineWidthl , & & fillColor = fillColor , fillPattern = fillPattern ) else call bar ( h (:, 1 ), h (:, 2 ), relWidth = relWidthl , lineWidth = lineWidthl , & & fillColor = fillColor ) end if else if ( present ( fillPattern )) then call bar ( h (:, 1 ), h (:, 2 ), h (:, 2 ), relWidth = relWidthl , lineWidth = lineWidthl , & & fillPattern = fillPattern ) else call bar ( h (:, 1 ), h (:, 2 ), h (:, 2 ), relWidth = relWidthl , lineWidth = lineWidthl ) end if end if end if call resetPen () end subroutine hist subroutine scatter ( x , y , c , s , markColor , markStyle , markSize ) !! Create scatter plot of data real ( wp ), dimension (:), intent ( in ) :: x !! x-coordinates of data real ( wp ), dimension (:), intent ( in ) :: y !! y-coordinates of data real ( wp ), dimension (:), intent ( in ), optional :: c !! Data for smooth coloring real ( wp ), dimension (:), intent ( in ), optional :: s !! Data for marker scaling character ( * ), intent ( in ), optional :: markColor !! Color of markers; overridden by z character ( * ), intent ( in ), optional :: markStyle !! Style of markers real ( wp ), intent ( in ), optional :: markSize !! Size of markers real ( pp ), dimension (:), allocatable :: xl , yl real ( pp ), dimension (:), allocatable :: cb character ( 32 ) :: code integer :: k xl = localize ( x ) yl = localize ( y ) if ( present ( markColor )) call setColor ( markColor ) code = getSymbolCode ( '' ) if ( present ( markStyle )) code = getSymbolCode ( markStyle ) if ( present ( markSize )) call plschr ( 0.0_pp , real ( markSize , pp )) if ( present ( markSize )) call plssym ( 0.0_pp , real ( markSize , pp )) if ( present ( c )) cb = real ( mixval ( c ), pp ) do k = 1 , size ( x ) if ( present ( c )) call plcol1 ( real ( ( c ( k ) - cb ( 1 )) / ( cb ( 2 ) - cb ( 1 )) , pp ) ) if ( present ( s )) call plschr ( 0.0_pp , real ( s ( k ), pp )) if ( present ( s )) call plssym ( 0.0_pp , real ( s ( k ), pp )) call plptex ( xl ( k ), yl ( k ), 0.0_pp , 0.0_pp , 0.5_pp , code ) end do call resetPen () end subroutine scatter subroutine plot ( x , y , lineColor , lineStyle , lineWidth , markColor , markStyle , markSize ) !! Plot data using lines and or markers real ( wp ), dimension (:), intent ( in ) :: x !! x-data for plot real ( wp ), dimension (:), intent ( in ) :: y !! y-data for plot character ( * ), intent ( in ), optional :: lineColor !! Color of line character ( * ), intent ( in ), optional :: lineStyle !! Style of line; '' for no line real ( wp ), intent ( in ), optional :: lineWidth !! Width of line character ( * ), intent ( in ), optional :: markColor !! Color of markers, if any character ( * ), intent ( in ), optional :: markStyle !! Style of markers; '' or absent for none real ( wp ), intent ( in ), optional :: markSize !! Size of markers, if any real ( pp ), dimension (:), allocatable :: xl , yl character ( 32 ) :: code integer :: k xl = localize ( x ) yl = localize ( y ) if ( present ( lineColor )) call setColor ( lineColor ) if ( present ( lineWidth )) call setLineWidth ( lineWidth ) if ( present ( lineStyle )) then call setLineStyle ( lineStyle ) if ( lineStyle /= '' ) call plline ( xl , yl ) else call plline ( xl , yl ) end if call resetPen () if ( present ( markColor )) call setColor ( markColor ) if ( present ( markSize )) call plssym ( 0.0_pp , real ( markSize , pp )) if ( present ( markStyle )) then code = getSymbolCode ( markStyle ) if ( markStyle /= '' ) then do k = 1 , size ( x ) call plptex ( xl ( k ), yl ( k ), 0.0_pp , 0.0_pp , 0.5_pp , code ) end do end if end if call resetPen () end subroutine plot subroutine plot3 ( x , y , z , lineColor , lineStyle , lineWidth , markColor , markStyle , markSize ) !! Plot data using lines and or markers real ( wp ), dimension (:), intent ( in ) :: x !! x-data for plot real ( wp ), dimension (:), intent ( in ) :: y !! y-data for plot real ( wp ), dimension (:), intent ( in ) :: z !! z-data for plot character ( * ), intent ( in ), optional :: lineColor !! Color of line character ( * ), intent ( in ), optional :: lineStyle !! Style of line; '' for no line real ( wp ), intent ( in ), optional :: lineWidth !! Width of line character ( * ), intent ( in ), optional :: markColor !! Color of markers, if any character ( * ), intent ( in ), optional :: markStyle !! Style of markers; '' or absent for none real ( wp ), intent ( in ), optional :: markSize !! Size of markers, if any real ( pp ), dimension (:), allocatable :: xl , yl , zl real ( pp ) :: dx , dy , dz , sx , sy , sz character ( 32 ) :: code integer :: k xl = localize ( x ) yl = localize ( y ) zl = localize ( z ) if ( present ( lineColor )) call setColor ( lineColor ) if ( present ( lineWidth )) call setLineWidth ( lineWidth ) if ( present ( lineStyle )) then call setLineStyle ( lineStyle ) if ( lineStyle /= '' ) call plline ( xl , yl ) else call plline3 ( xl , yl , zl ) end if call resetPen () if ( present ( markColor )) call setColor ( markColor ) if ( present ( markSize )) call plssym ( 0.0_pp , real ( markSize , pp )) if ( present ( markStyle )) then code = getSymbolCode ( markStyle ) if ( markStyle /= '' ) then dx = 1.0_pp dy = 0.0_pp dz = 0.0_pp sx = 0.0_pp sy = 0.0_pp sz = 0.0_pp do k = 1 , size ( x ) call plptex3 ( xl ( k ), yl ( k ), zl ( k ), dx , dy , dz , sx , sy , sz , 0.5_pp , code ) end do end if end if call resetPen () end subroutine plot3 subroutine contour ( x , y , z , N , lineColor , lineStyle , lineWidth ) !! Plot contour lines real ( wp ), dimension (:), intent ( in ) :: x !! x-coordinates of data real ( wp ), dimension (:), intent ( in ) :: y !! y-coordinates of data real ( wp ), dimension (:,:), intent ( in ) :: z !! Data for contouring integer , intent ( in ), optional :: N !! Number of levels to use in contour character ( * ), intent ( in ), optional :: lineColor !! Color of contour lines character ( * ), intent ( in ), optional :: lineStyle !! Style of contour lines real ( wp ), optional :: lineWidth !! Width of contour lines real ( pp ), dimension (:), allocatable :: xl , yl real ( pp ), dimension (:,:), allocatable :: zl real ( pp ), dimension (:), allocatable :: edge integer :: Nl , k xl = localize ( x ) yl = localize ( y ) zl = localize ( z ) Nl = 20 if ( present ( N )) Nl = N edge = [( real ( k - 1 , pp ) / real ( Nl - 1 , pp ) * ( maxval ( zl ) - minval ( zl )) + minval ( zl ) , k = 1 , Nl )] if ( present ( lineColor )) call setColor ( lineColor ) if ( present ( lineStyle )) call setLineStyle ( lineStyle ) if ( present ( lineWidth )) call setLineWidth ( lineWidth ) call plcont ( zl , edge , xl , yl ) call resetPen () end subroutine contour subroutine surface ( x , y , z , N , lineStyle ) !! Plot a 3d surface real ( wp ), dimension (:), intent ( in ) :: x !! x-coordinates of data real ( wp ), dimension (:), intent ( in ) :: y !! y-coordinates of data real ( wp ), dimension (:,:), intent ( in ) :: z !! Data for contouring integer , intent ( in ), optional :: N !! Number of levels to use in surface colors character ( * ), intent ( in ), optional :: lineStyle !! Style for xy lines ( '-' = on, '' = off ) real ( pp ), dimension (:), allocatable :: xl , yl real ( pp ), dimension (:,:), allocatable :: zl real ( pp ), dimension (:), allocatable :: edge integer :: Nl , opt opt = MAG_COLOR xl = localize ( x ) yl = localize ( y ) zl = localize ( z ) Nl = 20 if ( present ( N )) then Nl = N opt = ior ( opt , SURF_CONT ) end if edge = localize ( linspace ( minval ( z ), maxval ( z ), Nl )) if ( present ( lineStyle )) then select case ( lineStyle ) case ( '' ) opt = opt case ( '-' ) opt = ior ( opt , FACETED ) end select end if call plsurf3d ( xl , yl , zl , opt , edge ) call resetPen () end subroutine surface subroutine wireframe ( x , y , z , lineColor ) !! Plot a 3d wireframe real ( wp ), dimension (:), intent ( in ) :: x !! x-coordinates of data real ( wp ), dimension (:), intent ( in ) :: y !! y-coordinates of data real ( wp ), dimension (:,:), intent ( in ) :: z !! Data for contouring character ( * ), intent ( in ), optional :: lineColor !! Color of contour lines real ( pp ), dimension (:), allocatable :: xl , yl real ( pp ), dimension (:,:), allocatable :: zl xl = localize ( x ) yl = localize ( y ) zl = localize ( z ) if ( present ( lineColor )) then call setColor ( lineColor ) call plot3d ( xl , yl , zl , DRAW_LINEXY ,. false .) else call plot3d ( xl , yl , zl , ior ( DRAW_LINEXY , MAG_COLOR ),. false .) end if call resetPen () end subroutine wireframe subroutine contourf ( x , y , z , N ) !! Plot filled contours real ( wp ), dimension (:), intent ( in ) :: x !! x-coordinates of data real ( wp ), dimension (:), intent ( in ) :: y !! y-coordinates of data real ( wp ), dimension (:,:), intent ( in ) :: z !! Data for contouring integer , intent ( in ), optional :: N !! Number of levels to use in contour real ( pp ), dimension (:), allocatable :: xl , yl real ( pp ), dimension (:,:), allocatable :: zl real ( pp ), dimension (:), allocatable :: edge character ( 1 ) :: defined real ( pp ) :: fill_width real ( pp ) :: cont_width integer :: cont_color integer :: Nl xl = localize ( x ) yl = localize ( y ) zl = localize ( z ) Nl = 20 if ( present ( N )) Nl = N edge = localize ( linspace ( minval ( z ), maxval ( z ), Nl )) fill_width = - 1.0_pp cont_width = - 1.0_pp cont_color = - 1 call plshades ( zl , defined , minval ( xl ), maxval ( xl ), minval ( yl ), maxval ( yl ), & & edge , fill_width , cont_color , cont_width ) call resetPen () end subroutine contourf subroutine quiver ( x , y , u , v , s , c , scaling , lineColor , lineStyle , lineWidth ) !! Plot vectors real ( wp ), dimension (:), intent ( in ) :: x !! x-positions of vectors real ( wp ), dimension (:), intent ( in ) :: y !! y-positions of vectors real ( wp ), dimension (:,:), intent ( in ) :: u !! u-components of vectors real ( wp ), dimension (:,:), intent ( in ) :: v !! v-components of vectors real ( wp ), dimension (:,:), intent ( in ), optional :: s !! Scale of vectors real ( wp ), dimension (:,:), intent ( in ), optional :: c !! Color values for vectors real ( wp ), intent ( in ), optional :: scaling !! Scaling of vectors !! < 0 = Automatic, then scaled !!   0 = Automatic !! > 0 = Directly scaled character ( * ), intent ( in ), optional :: lineColor !! Color of vectors character ( * ), intent ( in ), optional :: lineStyle !! Style of vectors' lines real ( wp ), optional :: lineWidth !! Width of vectors' lines real ( pp ), dimension (:), allocatable :: xl , yl real ( pp ), dimension (:,:), allocatable :: ul , vl , sl real ( pp ), dimension ( 2 ) :: xb , yb , sb , cb , d real ( pp ) :: scalingl , scl , mag , clr integer :: i , j xl = localize ( x ) yl = localize ( y ) ul = localize ( u ) vl = localize ( v ) d = real ([ x ( 2 ) - x ( 1 ), y ( 2 ) - y ( 1 )], pp ) xb = real ( mixval ( x ), pp ) yb = real ( mixval ( y ), pp ) if ( present ( s )) then sl = localize ( s ) sl = sl / maxval ( sl ) else sl = localize ( u ** 2 + v ** 2 ) sl = sqrt ( sl ) sl = sl / maxval ( sl ) end if sb = [ minval ( sl ), maxval ( sl )] cb = 0.0_wp if ( present ( c )) cb = real ([ minval ( c ), maxval ( c )], pp ) scalingl = 1.0_pp if ( present ( scaling )) scalingl = real ( scaling , pp ) if ( present ( lineColor )) call setColor ( lineColor ) if ( present ( lineStyle )) call setLineStyle ( lineStyle ) if ( present ( lineWidth )) call setLineWidth ( lineWidth ) do i = 1 , size ( u , 1 ) do j = 1 , size ( u , 2 ) mag = norm2 ([ ul ( i , j ), vl ( i , j )]) scl = scalingl * norm2 ( d ) * sl ( i , j ) if ( abs ( scl ) < 1.0E-5_wp ) cycle if ( present ( c )) then clr = real ( ( c ( i , j ) - cb ( 1 )) / ( cb ( 2 ) - cb ( 1 )) , pp ) clr = max ( clr , 0.0_pp ) clr = min ( clr , 1.0_pp ) call plcol1 ( clr ) end if call plvect ( ul ( i : i , j : j ) / mag , vl ( i : i , j : j ) / mag , scl , xl ( i : i ), yl ( j : j )) end do end do call resetPen () end subroutine quiver subroutine bar ( x , y , c , relWidth , fillColor , fillPattern , lineColor , lineWidth ) !! Create a bar graph real ( wp ), dimension (:), intent ( in ) :: x !! x-positions of the bars' centers real ( wp ), dimension (:), intent ( in ) :: y !! y-positions of the bars' tops real ( wp ), dimension (:), intent ( in ), optional :: c !! Color scale for bars real ( wp ), intent ( in ), optional :: relWidth !! Relative width of bars (default 0.8) character ( * ), intent ( in ), optional :: fillColor !! Color of bar fills character ( * ), intent ( in ), optional :: fillPattern !! Pattern of bar fills character ( * ), intent ( in ), optional :: lineColor !! Color of lines around bars real ( wp ), optional :: lineWidth !! Width of lines around bars real ( pp ), dimension ( 4 ) :: xl , yl real ( pp ), dimension ( 2 ) :: cb real ( pp ) :: dx , dxs integer :: k cb = 0.0_wp if ( present ( c )) cb = real ( mixval ( c ), pp ) dxs = 0.8_pp if ( present ( relWidth )) dxs = real ( relWidth , pp ) if ( size ( x ) > 1 ) then dx = dxs * real ( x ( 2 ) - x ( 1 ), pp ) / 2.0_pp else dx = dxs end if if ( present ( lineWidth )) call setLineWidth ( lineWidth ) do k = 1 , size ( x ) xl = real ([ x ( k ) - dx , x ( k ) - dx , x ( k ) + dx , x ( k ) + dx ], pp ) yl = real ([ 0.0_wp , y ( k ), y ( k ), 0.0_wp ], pp ) if ( present ( fillColor )) call setColor ( fillColor ) if ( present ( fillPattern )) call setFillPattern ( fillPattern ) if ( present ( c )) call plcol1 ( real ( ( c ( k ) - cb ( 1 )) / ( cb ( 2 ) - cb ( 1 )) , pp ) ) call plfill ( xl , yl ) if ( present ( lineColor )) call setColor ( lineColor ) call plline ( xl , yl ) end do call resetPen () end subroutine bar subroutine barh ( y , x , c , relWidth , fillColor , fillPattern , lineColor , lineWidth ) !! Create a horizontal bar graph real ( wp ), dimension (:), intent ( in ) :: y !! y-positions of the bars' centers real ( wp ), dimension (:), intent ( in ) :: x !! x-positions of the bars' tops real ( wp ), dimension (:), intent ( in ), optional :: c !! Color scale for bars real ( wp ), intent ( in ), optional :: relWidth !! Relative width of bars character ( * ), intent ( in ), optional :: fillColor !! Color of bar fills character ( * ), intent ( in ), optional :: fillPattern !! Pattern of bar fills character ( * ), intent ( in ), optional :: lineColor !! Color of lines around bars real ( wp ), optional :: lineWidth !! Width of lines around bars real ( pp ), dimension ( 4 ) :: xl , yl real ( pp ), dimension ( 2 ) :: cb real ( pp ) :: dy , dys integer :: k cb = 0.0_wp if ( present ( c )) cb = real ( mixval ( c ), pp ) dys = 0.8_pp if ( present ( relWidth )) dys = real ( relWidth , pp ) dy = dys * real ( y ( 2 ) - y ( 1 ), pp ) / 2.0_pp if ( present ( lineWidth )) call setLineWidth ( lineWidth ) do k = 1 , size ( x ) yl = real ([ y ( k ) - dy , y ( k ) - dy , y ( k ) + dy , y ( k ) + dy ], pp ) xl = real ([ 0.0_wp , x ( k ), x ( k ), 0.0_wp ], pp ) if ( present ( fillColor )) call setColor ( fillColor ) if ( present ( fillPattern )) call setFillPattern ( fillPattern ) if ( present ( c )) call plcol1 ( real ( ( c ( k ) - cb ( 1 )) / ( cb ( 2 ) - cb ( 1 )) , pp ) ) call plfill ( xl , yl ) if ( present ( lineColor )) call setColor ( lineColor ) call plline ( xl , yl ) end do call resetPen () end subroutine barh subroutine fillBetween ( x , y1 , y0 , fillColor , fillPattern , lineWidth ) !! Fill space between two lines real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y1 real ( wp ), dimension (:), intent ( in ), optional :: y0 character ( * ), intent ( in ), optional :: fillColor character ( * ), intent ( in ), optional :: fillPattern real ( wp ), intent ( in ), optional :: lineWidth real ( pp ), dimension (:), allocatable :: xl , y1l , y0l integer :: N N = size ( x ) xl = localize ( x ) y1l = localize ( y1 ) if ( present ( y0 )) then y0l = localize ( y0 ) else allocate ( y0l ( N )) y0l = 0.0_pp end if if ( present ( fillColor )) call setColor ( fillColor ) if ( present ( fillPattern )) call setFillPattern ( fillPattern ) if ( present ( lineWidth )) call setLineWidth ( lineWidth ) call plfill ([ xl ( 1 : N : 1 ), xl ( N : 1 : - 1 )],[ y1l ( 1 : N : 1 ), y0l ( N : 1 : - 1 )]) call resetPen () end subroutine fillBetween subroutine fillBetweenx ( y , x1 , x0 , fillColor , fillPattern , lineWidth ) !! Fill space between two lines real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: x1 real ( wp ), dimension (:), intent ( in ), optional :: x0 character ( * ), intent ( in ), optional :: fillColor character ( * ), intent ( in ), optional :: fillPattern real ( wp ), intent ( in ), optional :: lineWidth real ( pp ), dimension (:), allocatable :: yl , x1l , x0l integer :: N N = size ( y ) yl = localize ( y ) x1l = localize ( x1 ) if ( present ( x0 )) then x0l = localize ( x0 ) else allocate ( x0l ( N )) x0l = 0.0_pp end if if ( present ( fillColor )) call setColor ( fillColor ) if ( present ( fillPattern )) call setFillPattern ( fillPattern ) if ( present ( lineWidth )) call setLineWidth ( lineWidth ) call plfill ([ x1l ( 1 : N : 1 ), x0l ( N : 1 : - 1 )],[ yl ( 1 : N : 1 ), yl ( N : 1 : - 1 )]) call resetPen () end subroutine fillBetweenx subroutine errorbar ( x , y , xerr , yerr , lineColor , lineStyle , lineWidth ) !! Plot error bars for a set of data points real ( wp ), dimension (:), intent ( in ) :: x !! x-data for plot real ( wp ), dimension (:), intent ( in ) :: y !! y-data for plot real ( wp ), dimension (:), intent ( in ), optional :: xerr !! x-data error for plot real ( wp ), dimension (:), intent ( in ), optional :: yerr !! y-data error for plot character ( * ), intent ( in ), optional :: lineColor !! Color of line character ( * ), intent ( in ), optional :: lineStyle !! Style of line; '' for no line real ( wp ), intent ( in ), optional :: lineWidth !! Width of line real ( pp ), dimension (:), allocatable :: xl , yl real ( pp ), dimension (:), allocatable :: xll , xlh real ( pp ), dimension (:), allocatable :: yll , ylh xl = localize ( x ) yl = localize ( y ) if ( present ( lineColor )) call setColor ( lineColor ) if ( present ( lineWidth )) call setLineWidth ( lineWidth ) if ( present ( lineStyle )) call setLineStyle ( lineStyle ) if ( present ( xerr )) then xll = localize ( x - xerr ) xlh = localize ( x + xerr ) call plerrx ( xll , xlh , yl ) end if if ( present ( yerr )) then yll = localize ( y - yerr ) ylh = localize ( y + yerr ) call plerry ( xl , yll , ylh ) end if call resetPen () end subroutine !========================! != Drawing Pen Routines =! !========================! subroutine resetPen !! Reset pen to default state call setColor ( '' ) call setLineStyle ( '' ) call setLineWidth ( 0.5_wp ) call setFillPattern ( '' ) call plschr ( 0.0_pp , real ( fontScale , pp )) call plssym ( 0.0_pp , real ( fontScale , pp )) end subroutine resetPen subroutine setLineWidth ( lineWidth ) real ( wp ), intent ( in ) :: lineWidth call plwidth ( real ( lineWidth , pp )) end subroutine setLineWidth subroutine setLineStyle ( style ) !! Set the current pen line style character ( * ), intent ( in ) :: style !! Style to set call pllsty ( getLineStyleCode ( style )) end subroutine setLineStyle function getLineStyleCode ( style ) result ( code ) !! Return the code for a line style character ( * ), intent ( in ) :: style !! Style desired integer :: code select case ( style ) case ( '-' ) code = 1 case ( ':' ) code = 2 case ( '--' ) code = 3 case default code = 1 end select end function getLineStyleCode function getSymbolCode ( style ) result ( code ) !! Return the code for a symbol style character ( * ), intent ( in ) :: style !! Style desired character ( 32 ) :: code select case ( style ) case ( '+' ) code = '#(140)' case ( 'x' ) code = '#(141)' case ( '*' ) code = '#(142)' case ( '.' ) code = '#(143)' case ( 's' ) code = '#(144)' case ( ',' ) code = '#(850)' case ( '&#94;' ) code = '#(852)' case ( '<' ) code = '#(853)' case ( 'v' ) code = '#(854)' case ( '>' ) code = '#(855)' case default code = '#(143)' end select end function getSymbolCode subroutine setFillPattern ( style ) character ( * ), intent ( in ) :: style call plpsty ( getFillCode ( style )) end subroutine setFillPattern function getFillCode ( style ) result ( code ) character ( * ), intent ( in ) :: style integer :: code select case ( style ) case ( '' ) code = 0 case ( '-' ) code = 1 case ( '/' ) code = 3 case ( '|' ) code = 2 case ( '\\') code = 4 case(' # ') code = 7 case(' x ') code = 8 case default code = 0 end select end function getFillCode subroutine setColor(color) !! Set the current pen color character(*),intent(in)::color !! Name of color to set integer::ios real(pp)::v read(color,*,iostat=ios) v if(ios==0) then call plcol1(v) else call plcol0(getColorCode(color)) end if end subroutine setColor function getColorCode(color) result(code) character(*),intent(in)::color integer::code select case(color) case(' w ',' white ') if(blackOnWhite) then code = 1 else code = 2 end if case(' k ',' black ') if(blackOnWhite) then code = 2 else code = 1 end if case(' r ',' red ') code = 3 case(' g ',' green ') code = 4 case(' b ',' blue ') code= 5 case(' c ',' cyan ') code = 6 case(' m ',' magenta ') code= 7 case(' y ',' yellow ') code = 8 case(' fg ') code = 2 case(' bg ') code = 1 case default code = 2 end select code = code-1 end function getColorCode !===========================! != Library Status Routines =! !===========================! subroutine setup(device,fileName,fontScaling,whiteOnBlack,transparent,colormap,figSize) !! Setup PlPlot library, optionally overriding defaults character(*),intent(in),optional::device !! Output device to use !! !! * qtwidget !! * svgqt !! * pngqt character(*),intent(in),optional::fileName !! Name of file(s) to write to !! !! The text `%n` will be replaced with the figure number real(wp),intent(in),optional::fontScaling !! Font scaling relative to default value logical,intent(in),optional::whiteOnBlack !! Default foreground and background colors logical,intent(in),optional::transparent !! Transparent background character(*),intent(in),optional::colormap !! Colormap to use integer,dimension(2),intent(in),optional::figSize !! Size of figures to produce in pixels character(64)::bufx,bufy if(present(device)) then call plsdev(device) else call plsdev(default_dev) end if call plsfam(1,1,100) if(present(fileName)) then call plsfnam(fileName) else call plsfnam(' out ') end if if(present(whiteOnBlack)) blackOnWhite = .not. whiteOnBlack if(present(transparent)) transparentBackground = transparent call setIndexedColors() if(present(colormap)) then call setColormap(colormap) else call setColormap(' CoolWarm ') end if call plfontld(0) if(present(fontScaling)) fontScale = real(fontScaling,pp) if(present(figSize)) then write(bufx,*) figSize(1) write(bufy,*) figSize(2) call plsetopt(' geometry ',trim(adjustl(bufx))//' x '//trim(adjustl(bufy))) else call plsetopt(' geometry ',' 640 x480 ') end if call plinit() call resetPen() end subroutine setup subroutine show !! Show the plots end finialize the PlPlot library if(.not.didShow) then call plend() didShow = .true. end if end subroutine show !======================! != Color Map Routines =! !======================! subroutine setIndexedColors !! Setup the indexed colors integer,dimension(8,3)::rgb real(plflt),dimension(8)::a rgb(getColorCode(' w ')+1,:) = [255,255,255] ! White rgb(getColorCode(' k ')+1,:) = [  0,  0,  0] ! Black rgb(getColorCode(' r ')+1,:) = [255,  0,  0] ! Red rgb(getColorCode(' g ')+1,:) = [  0,255,  0] ! Green rgb(getColorCode(' b ')+1,:) = [  0,  0,255] ! Blue rgb(getColorCode(' c ')+1,:) = [  0,255,255] ! Cyan rgb(getColorCode(' m ')+1,:) = [255,  0,255] ! Magenta rgb(getColorCode(' y ')+1,:) = [255,255,  0] ! Yellow a = 1.0_plflt if(transparentBackground) a(1) = 0.0_wp call plscmap0a(rgb(:,1),rgb(:,2),rgb(:,3),a) end subroutine setIndexedColors subroutine setColormap(colormap) !! Set the continuous colormap character(*),intent(in)::colormap !! Name of colormap to use real(pp),dimension(:),allocatable::i,h,s,v select case(colormap) case(' CoolWarm ') h = [240.0,195.0,45.0,0.0] s = [0.60, 0.95, 0.95, 0.60] v = [0.80, 0.30, 0.30, 0.80] i = [0.00, 0.50, 0.50, 1.00] call plscmap1n(256) call plscmap1l(.false.,i,h,s,v) case(' Gray ') call plspal1(' cmap1_gray . pal ',1) case(' BlueYellow ') call plspal1(' cmap1_blue_yellow . pal ',1) case(' BlueRed ') call plspal1(' cmap1_blue_red . pal ',1) case(' Radar ') call plspal1(' cmap1_radar . pal ',1) case(' HighFreq ') call plspal1(' cmap1_highfreq . pal ',1) case(' LowFreq ') call plspal1(' cmap1_lowfreq . pal ' , 1 ) end select end subroutine setColormap end module plplotlib_mod","tags":"","loc":"sourcefile/plplotlib.f90.html","title":"plplotlib.f90 – PlPlotLib"},{"text":"Source Code module kinds_mod !! Module to manage kinds for the program implicit none private !==============! != Real Kinds =! !==============! integer , parameter :: sp = selected_real_kind ( 6 ) !! Single precision integer , parameter :: dp = selected_real_kind ( 15 ) !! Double precision integer , parameter :: ep = selected_real_kind ( 18 ) !! Extended precision integer , parameter :: qp = selected_real_kind ( 32 ) !! Quad precision integer , parameter :: wp = ep !! Set working precision to double !==================! != Math Constants =! !==================! real ( wp ), parameter :: PI = 4.0_wp * atan ( 1.0_wp ) !! Archimedes' constant real ( wp ), parameter :: E = exp ( 1.0_wp ) !! Euler's constant !===========! != Exports =! !===========! public :: wp public :: PI , E public :: printTypes contains subroutine printTypes !! Print the integer kinds for each real type write ( * , * ) 'sp: ' , sp write ( * , * ) 'dp: ' , dp write ( * , * ) 'ep: ' , ep write ( * , * ) 'qp: ' , qp write ( * , * ) 'wp: ' , wp end subroutine printTypes end module kinds_mod","tags":"","loc":"sourcefile/kinds.f90.html","title":"kinds.f90 – PlPlotLib"},{"text":"Source Code program basic_prg !! Create a basic plot !! !! ![plot](|media|/basic-1.svg) use kinds_mod use utilities_mod use plplotlib_mod implicit none real ( wp ), dimension (:), allocatable :: x , y x = linspace ( - 2.0_wp , 2.0_wp , 101 ) y = x ** 2 - 1.0_wp call setup ( device = 'svgqt' , fileName = 'examples/basic-%n.svg' , figSize = [ 400 , 300 ]) call figure () call subplot ( 1 , 1 , 1 ) call xylim ( mixval ( x ), mixval ( y )) call plot ( x , y , lineColor = 'r' , lineWidth = 2.0_wp ) call ticks () call labels ( '#fix#fn' , '#fiy#fn' , 'Plot' ) call show () end program basic_prg","tags":"","loc":"sourcefile/basic.f90.html","title":"basic.f90 – PlPlotLib"},{"text":"Source Code program logo_prg !! Create the project logo use kinds_mod use utilities_mod use plplotlib_mod implicit none call setup ( device = 'svgqt' , fileName = 'logo-%n.png' , figSize = [ 128 , 128 ]) call makeLogo call show () contains subroutine makeLogo real ( wp ), dimension (:), allocatable :: x , y1 , y2 , y3 x = linspace ( 0.0_wp , 1.0_wp , 100 ) y1 = x ** 2 - 1.0_wp y2 = 2.0_wp * x - 1.0_wp y3 = x y3 = cos ( 2.0_wp * PI * x ) call figure () call subplot ( 1 , 1 , 1 ) call xylim ( mixval ( x ), mixval ([ y1 , y2 , y3 ]) * 1.1_wp ) call plot ( x , y1 , lineColor = 'b' , lineWidth = 1 0.0_wp ) call plot ( x , y2 , lineColor = 'r' , lineWidth = 1 0.0_wp ) call plot ( x , y3 , lineColor = 'c' , lineWidth = 1 0.0_wp ) call ticks ( lineWidth = 5.0_wp ) call labels ( '' , '' , '' ) end subroutine makeLogo end program logo_prg","tags":"","loc":"sourcefile/logo.f90.html","title":"logo.f90 – PlPlotLib"},{"text":"Source Code program examples_prg !! A collection of example plots use kinds_mod use plplotlib_mod implicit none call setup ( device = 'svgqt' , fileName = 'examples/example-%n.svg' , figSize = [ 320 , 240 ], transparent = . true .) call doPlot () call doScatter () call doContour () call doLegend () call doQuiver () call doBar () call doFillBetween () call doHist () call doSurface () call doError () call doLogPlot () call show () contains subroutine doPlot !! ![plot](|media|/example-1.svg) integer , parameter :: N = 20 real ( wp ), dimension ( N ) :: x , y x = linspace ( 0.0_wp , 1.0_wp , N ) y = x ** 2 - 1.0_wp call figure () call subplot ( 1 , 1 , 1 ) call xylim ( mixval ( x ), mixval ( y )) call plot ( x , y , lineColor = 'red' , lineWidth = 2.0_wp , & & markStyle = '.' , markColor = 'cyan' , markSize = 2.0_wp ) call plot ( x , - 1.0_wp - y , lineColor = 'blue' , lineStyle = ':' , lineWidth = 2.0_wp , & & markStyle = '+' , markColor = 'green' , markSize = 1.0_wp ) !~ \t\tcall ticks() call xticks ( primary = . true ., secondary = . false .) call yticks ( primary = . true ., secondary = . false .) !~ \t\tcall labels('x','y','f(x)=x#u2#d-1; g(x)=-x#u2#d') call xlabel ( 'x' ) call ylabel ( 'y' ) call title ( 'f(x)=x#u2#d-1; g(x)=-x#u2#d' ) end subroutine doPlot subroutine doScatter !! ![scatter](|media|/example-2.svg) integer , parameter :: N = 100 real ( wp ), dimension ( N ) :: x , y , z call random_number ( x ) call random_number ( y ) z = sqrt ( x ** 2 + y ** 2 ) call figure () call subplot ( 2 , 2 , 1 ) call xylim ([ 0.0_wp , 1.0_wp ],[ 0.0_wp , 1.0_wp ]) call scatter ( x , y ) call ticks () call labels ( 'x' , 'y' , '' ) call subplot ( 2 , 2 , 2 ) call xylim ([ 0.0_wp , 1.0_wp ],[ 0.0_wp , 1.0_wp ]) call scatter ( x , y , c = z ) call ticks () call labels ( 'x' , 'y' , '' ) call subplot ( 2 , 2 , 3 ) call xylim ([ 0.0_wp , 1.0_wp ],[ 0.0_wp , 1.0_wp ]) call scatter ( x , y , s = ( 4.0_wp * z + 1.0_wp ), markColor = 'blue' ) call ticks () call labels ( 'x' , 'y' , '' ) call subplot ( 2 , 2 , 4 ) call xylim ([ 0.0_wp , 1.0_wp ],[ 0.0_wp , 1.0_wp ]) call scatter ( x , y , c = z , s = ( 4.0_wp * z + 1.0_wp )) call ticks () call labels ( 'x' , 'y' , '' ) end subroutine doScatter subroutine doContour !! ![contour](|media|/example-3.svg) integer , parameter :: N = 50 real ( wp ), dimension ( N ) :: x , y real ( wp ), dimension ( N , N ) :: z integer :: i , j x = linspace ( - 1 0.0_wp , 1 0.0_wp , N ) y = linspace ( - 1 0.0_wp , 1 0.0_wp , N ) forall ( i = 1 : N , j = 1 : N ) z ( i , j ) = sin ( sqrt ( x ( i ) ** 2 + y ( j ) ** 2 ) ) / sqrt ( x ( i ) ** 2 + y ( j ) ** 2 ) end forall call figure () call subplot ( 1 , 1 , 1 , aspect = 1.0_wp ) call xylim ( mixval ( x ), mixval ( y )) call contourf ( x , y , z , 10 ) call contour ( x , y , z , 10 ) call colorbar ( z , 5 ) call ticks () call labels ( 'x' , 'y' , '' ) end subroutine doContour subroutine doLegend !! ![legend](|media|/example-4.svg) integer , parameter :: N = 20 real ( wp ), dimension ( N ) :: x , y character ( 32 ), dimension ( 3 , 7 ) :: series x = linspace ( 0.0_wp , 1.0_wp , N ) y = x ** 2 - 1.0_wp call figure () call subplot ( 1 , 1 , 1 ) call xylim ( mixval ( x ), mixval ( y )) call plot ( x , y , lineColor = 'red' , lineWidth = 2.0_wp , & & markStyle = '.' , markColor = 'cyan' , markSize = 2.0_wp ) call plot ( x , - 1.0_wp - y , lineColor = 'blue' , lineStyle = ':' , lineWidth = 2.0_wp , & & markStyle = '+' , markColor = 'green' , markSize = 1.0_wp ) ! [name,textColor,lineStyle,lineColor,markStyle,markColor] series ( 1 ,:) = [ character ( 32 ) :: 'f(x)=x#u2#d-1' , '' , '-' , 'r' , '.' , 'c' , '' ] series ( 2 ,:) = [ character ( 32 ) :: 'g(x)=-x#u2#d' , '' , ':' , 'b' , '+' , 'g' , '' ] series ( 3 ,:) = [ character ( 32 ) :: 'Box' , '' , '' , '' , '' , '' , 'r' ] call legend ( 'center left' , series ) call ticks () call labels ( 'x' , 'y' , '' ) end subroutine doLegend subroutine doQuiver !! ![quiver](|media|/example-5.svg) integer , parameter :: N = 20 real ( wp ), dimension ( N ) :: x , y real ( wp ), dimension ( N , N ) :: u , v , m integer :: i , j x = linspace ( - 1 0.0_wp , 1 0.0_wp , N ) y = linspace ( - 1 0.0_wp , 1 0.0_wp , N ) forall ( i = 1 : N , j = 1 : N ) u ( i , j ) = - y ( j ) v ( i , j ) = x ( i ) m ( i , j ) = sqrt ( u ( i , j ) ** 2 + v ( i , j ) ** 2 ) end forall call figure () call subplot ( 1 , 1 , 1 , aspect = 1.0_wp ) call xylim ( mixval ( x ), mixval ( y )) call quiver ( x , y , u , v , c = m , s = m , scaling = 2.0_wp , lineWidth = 2.0_wp ) call colorbar ( m , 10 ) call ticks () call labels ( 'x' , 'y' , '' ) end subroutine doQuiver subroutine doBar !! ![bar](|media|/example-6.svg) integer , parameter :: N = 21 real ( wp ), dimension ( N ) :: x , y x = linspace ( - PI , PI , N ) y = exp ( - x ** 2 ) call figure () call subplot ( 1 , 2 , 1 ) call xylim ( mixval ( x ) + [ - 0.1_wp , 0.1_wp ], mixval ( y ) + [ 0.0_wp , 0.1_wp ]) call bar ( x , y , c = y , relWidth = 1.0_wp ) call ticks () call labels ( 'x' , 'y' , '' ) call subplot ( 1 , 2 , 2 ) call xylim ( mixval ( y ) + [ 0.0_wp , 0.1_wp ], mixval ( x ) + [ - 0.1_wp , 0.1_wp ]) call barh ( x , y , fillColor = 'r' , relWidth = 1.0_wp ) call ticks () call labels ( 'x' , 'y' , '' ) end subroutine doBar subroutine doFillBetween !! ![fillBetween](|media|/example-7.svg) integer , parameter :: N = 51 real ( wp ), dimension ( N ) :: x , y1 , y2 x = linspace ( - 3.0_wp , 3.0_wp , N ) y1 = x ** 2 - 1.0_wp y2 = x ** 3 - 1.0_wp call figure () call subplot ( 1 , 1 , 1 ) call xylim ( mixval ( x ), mixval ([ y1 , y2 ])) call fillBetween ( x , y1 , y2 , fillColor = 'c' , fillPattern = '#' , lineWidth = 2.0_wp ) call plot ( x , y1 , lineColor = 'k' , lineWidth = 3.0_wp ) call plot ( x , y2 , lineColor = 'k' , lineWidth = 3.0_wp ) call ticks ( color = 'b' , lineWidth = 3.0_wp ) call labels ( 'x' , 'y' , 'f(x)=x#u2#d-1' , color = 'r' ) end subroutine doFillBetween subroutine doHist !! ![hist](|media|/example-8.svg) integer , parameter :: N = 10000 real ( wp ), dimension ( N , 12 ) :: r real ( wp ), dimension ( N ) :: x real ( wp ), dimension (:,:), allocatable :: h call random_number ( r ) x = sum ( r , 2 ) - 6.0_wp call figure () call subplot ( 1 , 2 , 1 ) call xylim ( mixval ( x ),[ 0.0_wp , 1.05_wp ]) call hist ( x , 20 ) call ticks () h = binData ( x , 20 , normalize = 2 ) call subplot ( 1 , 2 , 2 ) call xylim ( mixval ( h (:, 1 )),[ 0.0_wp , 1.05_wp * maxval ( h (:, 2 ))]) call bar ( h (:, 1 ), h (:, 2 ), c = h (:, 2 ), relWidth = 1.0_wp ) call ticks () end subroutine doHist subroutine doSurface !! ![surface](|media|/example-9.svg) integer , parameter :: N = 24 real ( wp ), dimension ( N ) :: x , y real ( wp ), dimension ( N , N ) :: z integer :: i , j x = linspace ( - 1 0.0_wp , 1 0.0_wp , N ) y = linspace ( - 1 0.0_wp , 1 0.0_wp , N ) forall ( i = 1 : N , j = 1 : N ) z ( i , j ) = sin ( sqrt ( x ( i ) ** 2 + y ( j ) ** 2 ) ) / sqrt ( x ( i ) ** 2 + y ( j ) ** 2 ) end forall call figure () call subplot ( 1 , 1 , 1 , is3d = . true .) call xyzlim ( mixval ( x ), mixval ( y ), mixval ( z ), zoom = 1.1_wp ) call surface ( x , y , z , 11 ) !~ \t\tcall wireframe(x,y,z,lineColor='k') call box ( 'x' , 'y' , 'z' ) end subroutine doSurface subroutine doError !! ![error](|media|/example-10.svg) integer , parameter :: N = 25 real ( wp ), dimension ( N ) :: x , y , xe , ye real ( wp ), dimension ( 12 ) :: r real ( wp ) :: m , s integer :: k x = linspace ( 0.0_wp , 5.0_wp , N ) y = 1.0_wp / ( x ** 2 + 1.0_wp ) do k = 1 , N call random_number ( r ) r = 0.25_wp * ( 2.0_wp * r - 1.0_wp ) m = sum ( r ) / real ( size ( r )) s = sqrt ( sum (( r - m ) ** 2 ) / real ( size ( r ) - 1 )) x ( k ) = x ( k ) + m xe ( k ) = s call random_number ( r ) r = 0.15_wp * ( 2.0_wp * r - 1.0_wp ) m = sum ( r ) / real ( size ( r )) s = sqrt ( sum (( r - m ) ** 2 ) / real ( size ( r ) - 1 )) y ( k ) = y ( k ) + m ye ( k ) = s end do call figure () call subplot ( 1 , 1 , 1 ) call xylim ( mixval ([ x - xe , x + xe ]) + [ - 0.5_wp , 0.5_wp ], mixval ([ y - ye , y + ye ]) + [ - 0.2_wp , 0.2_wp ]) call errorbar ( x , y , xerr = xe , yerr = ye , lineColor = 'b' , lineWidth = 1.0_wp ) call plot ( x , y , lineStyle = '' , markStyle = 's' , markColor = 'r' , markSize = 1.5_wp ) call ticks () call labels ( 'x' , 'y' , '' ) end subroutine doError subroutine doLogPlot !! ![logPlot](|media|/example-11.svg) integer , parameter :: N = 25 real ( wp ), dimension ( N ) :: x , y , yl x = linspace ( 0.0_wp , 5.0_wp , N ) y = exp ( - x ** 2 ) yl = log10 ( y ) call figure () call subplot ( 1 , 1 , 1 ) call xylim ( mixval ( x ), mixval ( yl )) call plot ( x , yl , lineColor = 'r' , lineWidth = 2.0_wp ) call ticks ( logy = . true .) call labels ( 'x [linear]' , 'y [log]' , 'exp(-x#u2#d)' ) end subroutine doLogPlot end program examples_prg","tags":"","loc":"sourcefile/examples.f90.html","title":"examples.f90 – PlPlotLib"},{"text":"Source Code program animate_prg !! Create a series of plots for an animation use kinds_mod use utilities_mod use plplotlib_mod implicit none real ( wp ), dimension (:), allocatable :: x , y , t integer :: N , M , i , k N = 100 M = 1000 x = linspace ( 0.0_wp , PI , N ) t = linspace ( 0.0_wp , 1 0.0_wp , M ) call setup () do k = 1 , M y = [( f ( x ( i ), t ( k )) , i = 1 , N )] call figure () call subplot ( 1 , 1 , 1 ) call xylim ( mixval ( x ),[ - 1.1_wp , 1.1_wp ]) call plot ( x , y , lineColor = 'b' , lineWidth = 2.0_wp ) call ticks () call labels ( 'x' , 'y' , '' ) end do call show () contains pure function f ( x , t ) result ( o ) real ( wp ), intent ( in ) :: x , t real ( wp ) :: o o = sin ( t ) * cos ( x + t ) end function f end program animate_prg","tags":"","loc":"sourcefile/animate.f90.html","title":"animate.f90 – PlPlotLib"},{"text":"public function linspace(l, h, N) result(o) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: l Low-bound for values real(kind=wp), intent(in) :: h High-bound for values integer, intent(in), optional :: N Number of values (default 20) Return Value real(kind=wp),\n  dimension(:),allocatable Description Return an array of evenly-spaced values Called By proc~~linspace~~CalledByGraph proc~linspace linspace proc~dofillbetween doFillBetween proc~dofillbetween->proc~linspace proc~dologplot doLogPlot proc~dologplot->proc~linspace proc~docontour doContour proc~docontour->proc~linspace proc~contourf contourf proc~docontour->proc~contourf program~basic_prg basic_prg program~basic_prg->proc~linspace program~animate_prg animate_prg program~animate_prg->proc~linspace proc~surface surface proc~surface->proc~linspace proc~dolegend doLegend proc~dolegend->proc~linspace proc~dobar doBar proc~dobar->proc~linspace proc~makelogo makeLogo proc~makelogo->proc~linspace proc~doerror doError proc~doerror->proc~linspace proc~doquiver doQuiver proc~doquiver->proc~linspace proc~doplot doPlot proc~doplot->proc~linspace proc~bindata binData proc~bindata->proc~linspace proc~contourf->proc~linspace proc~dosurface doSurface proc~dosurface->proc~linspace proc~dosurface->proc~surface program~examples_prg examples_prg program~examples_prg->proc~dofillbetween program~examples_prg->proc~dologplot program~examples_prg->proc~docontour program~examples_prg->proc~dolegend program~examples_prg->proc~dobar program~examples_prg->proc~doerror program~examples_prg->proc~doquiver program~examples_prg->proc~doplot program~examples_prg->proc~dosurface proc~dohist doHist program~examples_prg->proc~dohist program~logo_prg logo_prg program~logo_prg->proc~makelogo proc~dohist->proc~bindata proc~hist hist proc~dohist->proc~hist proc~hist->proc~bindata Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: Nl integer, public :: i Source Code function linspace ( l , h , N ) result ( o ) !! Return an array of evenly-spaced values real ( wp ), intent ( in ) :: l !! Low-bound for values real ( wp ), intent ( in ) :: h !! High-bound for values integer , intent ( in ), optional :: N !! Number of values (default 20) real ( wp ), dimension (:), allocatable :: o integer :: Nl , i Nl = 20 if ( present ( N )) Nl = N o = [( ( h - l ) * real ( i - 1 , wp ) / real ( Nl - 1 , wp ) + l , i = 1 , Nl )] end function linspace","tags":"","loc":"proc/linspace.html","title":"linspace – PlPlotLib"},{"text":"public function startsWith(text, str) result(o) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: text Text to search character(len=*), intent(in) :: str String to look for Return Value logical Description Test if text starts with str Called By proc~~startswith~~CalledByGraph proc~startswith startsWith none~getcorner getCorner none~getcorner->proc~startswith none~dolegendbox doLegendBox none~dolegendbox->none~getcorner proc~legend legend proc~legend->none~dolegendbox proc~dolegend doLegend proc~dolegend->proc~legend program~examples_prg examples_prg program~examples_prg->proc~dolegend Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: k Source Code function startsWith ( text , str ) result ( o ) !! Test if text starts with str character ( * ), intent ( in ) :: text !! Text to search character ( * ), intent ( in ) :: str !! String to look for logical :: o integer :: k k = len ( str ) o = text ( 1 : k ) == str end function startsWith","tags":"","loc":"proc/startswith.html","title":"startsWith – PlPlotLib"},{"text":"public function endsWith(text, str) result(o) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: text Text to search character(len=*), intent(in) :: str String to look for Return Value logical Description Test if text ends with str Called By proc~~endswith~~CalledByGraph proc~endswith endsWith none~getcorner getCorner none~getcorner->proc~endswith none~dolegendbox doLegendBox none~dolegendbox->none~getcorner proc~legend legend proc~legend->none~dolegendbox proc~dolegend doLegend proc~dolegend->proc~legend program~examples_prg examples_prg program~examples_prg->proc~dolegend Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: k Source Code function endsWith ( text , str ) result ( o ) !! Test if text ends with str character ( * ), intent ( in ) :: text !! Text to search character ( * ), intent ( in ) :: str !! String to look for logical :: o integer :: k k = len ( text ) o = text ( k - len ( str ) + 1 : k ) == str end function endsWith","tags":"","loc":"proc/endswith.html","title":"endsWith – PlPlotLib"},{"text":"public function randomNormal() result(o) Arguments None Return Value real(kind=wp) Description Return a sample from an approximate normal distribution\n with a mean of \\mu=0 and a standard deviation of\n \\sigma=1. In this approximate distribution, x\\in[-6,6]. Variables Type Visibility Attributes Name Initial real(kind=wp), public, dimension(12) :: x Source Code function randomNormal () result ( o ) !! Return a sample from an approximate normal distribution !! with a mean of \\mu=0 and a standard deviation of !! \\sigma=1. In this approximate distribution, x\\in[-6,6]. real ( wp ) :: o real ( wp ), dimension ( 12 ) :: x call random_number ( x ) o = sum ( x ) - 6.0_wp end function randomNormal","tags":"","loc":"proc/randomnormal.html","title":"randomNormal – PlPlotLib"},{"text":"public function randomUniform() result(o) Arguments None Return Value real(kind=wp) Description Return a sample from a uniform distribution\n in the range x\\in[-1,1]. Source Code function randomUniform () result ( o ) !! Return a sample from a uniform distribution !! in the range x\\in[-1,1]. real ( wp ) :: o call random_number ( o ) o = o * 2.0_wp - 1.0_wp end function randomUniform","tags":"","loc":"proc/randomuniform.html","title":"randomUniform – PlPlotLib"},{"text":"public function meshGridX(x, y) result(o) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x x-positions in grid real(kind=wp), intent(in), dimension(:) :: y y-positions in grid Return Value real(kind=wp),\n  dimension(:,:),allocatable Description Construct a 2d array of X values from a structured grid Variables Type Visibility Attributes Name Initial integer, public :: Nx integer, public :: Ny integer, public :: i integer, public :: j Source Code function meshGridX ( x , y ) result ( o ) !! Construct a 2d array of X values from a structured grid real ( wp ), dimension (:), intent ( in ) :: x !! x-positions in grid real ( wp ), dimension (:), intent ( in ) :: y !! y-positions in grid real ( wp ), dimension (:,:), allocatable :: o integer :: Nx , Ny integer :: i , j Nx = size ( x ) Ny = size ( y ) allocate ( o ( Nx , Ny )) forall ( i = 1 : Nx , j = 1 : Ny ) o ( i , j ) = x ( i ) end function meshGridX","tags":"","loc":"proc/meshgridx.html","title":"meshGridX – PlPlotLib"},{"text":"public function meshGridY(x, y) result(o) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x x-positions in grid real(kind=wp), intent(in), dimension(:) :: y y-positions in grid Return Value real(kind=wp),\n  dimension(:,:),allocatable Description Construct a 2d array of Y values from a structured grid Variables Type Visibility Attributes Name Initial integer, public :: Nx integer, public :: Ny integer, public :: i integer, public :: j Source Code function meshGridY ( x , y ) result ( o ) !! Construct a 2d array of Y values from a structured grid real ( wp ), dimension (:), intent ( in ) :: x !! x-positions in grid real ( wp ), dimension (:), intent ( in ) :: y !! y-positions in grid real ( wp ), dimension (:,:), allocatable :: o integer :: Nx , Ny integer :: i , j Nx = size ( x ) Ny = size ( y ) allocate ( o ( Nx , Ny )) forall ( i = 1 : Nx , j = 1 : Ny ) o ( i , j ) = y ( j ) end function meshGridY","tags":"","loc":"proc/meshgridy.html","title":"meshGridY – PlPlotLib"},{"text":"public function colorize(s, c) result(o) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String to colorize integer, , dimension(3) :: c Color code in [r,g,b] where r,g,b\\in[0,5] Return Value character(len=:),\n  allocatable Description Add terminal format codes to coloize a string Called By proc~~colorize~~CalledByGraph proc~colorize colorize proc~showprogress showProgress proc~showprogress->proc~colorize Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=1), public, parameter :: CR = achar(13) character(len=1), public, parameter :: ESC = achar(27) character(len=20), public :: pre character(len=3), public :: cb Source Code function colorize ( s , c ) result ( o ) !! Add terminal format codes to coloize a string character ( * ), intent ( in ) :: s !! String to colorize integer , dimension ( 3 ) :: c ! c in [0,5] !! Color code in [r,g,b] where r,g,b\\in[0,5] character (:), allocatable :: o character ( 1 ), parameter :: CR = achar ( 13 ) character ( 1 ), parameter :: ESC = achar ( 27 ) character ( 20 ) :: pre character ( 3 ) :: cb write ( cb , '(1I3)' ) 36 * c ( 1 ) + 6 * c ( 2 ) + c ( 3 ) + 16 pre = ESC // '[38;5;' // trim ( adjustl ( cb )) // 'm' o = trim ( pre ) // s // ESC // '[0m' end function colorize","tags":"","loc":"proc/colorize.html","title":"colorize – PlPlotLib"},{"text":"public elementalfunction real2char(a, f, l) result(o) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a Real value to convert character(len=*), intent(in), optional :: f Format of result integer, intent(in), optional :: l Length of result Return Value character(len=:),\n  allocatable Description Convert a real to a character Called By proc~~real2char~~CalledByGraph proc~real2char real2char proc~showprogress showProgress proc~showprogress->proc~real2char Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=128), public :: buf Source Code elemental function real2char ( a , f , l ) result ( o ) !! Convert a real to a character real ( wp ), intent ( in ) :: a !! Real value to convert character ( * ), optional , intent ( in ) :: f !! Format of result integer , optional , intent ( in ) :: l !! Length of result character (:), allocatable :: o character ( 128 ) :: buf if ( present ( l )) then allocate ( character ( l ) :: o ) if ( present ( f )) then write ( o , '(' // f // ')' ) a else write ( o , * ) a end if else if ( present ( f )) then write ( buf , '(' // f // ')' ) a else write ( buf , * ) a end if o = trim ( adjustl ( buf )) end if end function real2char","tags":"","loc":"proc/real2char.html","title":"real2char – PlPlotLib"},{"text":"public elementalfunction int2char(a, f, l) result(o) Arguments Type Intent Optional Attributes Name integer, intent(in) :: a Integer value to convert character(len=*), intent(in), optional :: f Format of result integer, intent(in), optional :: l Length of result Return Value character(len=:),\n  allocatable Description Convert an integer to a character Variables Type Visibility Attributes Name Initial character(len=128), public :: buf Source Code elemental function int2char ( a , f , l ) result ( o ) !! Convert an integer to a character integer , intent ( in ) :: a !! Integer value to convert character ( * ), optional , intent ( in ) :: f !! Format of result integer , optional , intent ( in ) :: l !! Length of result character (:), allocatable :: o character ( 128 ) :: buf if ( present ( l )) then allocate ( character ( l ) :: o ) if ( present ( f )) then write ( o , '(' // f // ')' ) a else write ( o , * ) a end if else if ( present ( f )) then write ( buf , '(' // f // ')' ) a else write ( buf , * ) a end if o = trim ( adjustl ( buf )) end if end function int2char","tags":"","loc":"proc/int2char.html","title":"int2char – PlPlotLib"},{"text":"public function mean(d) result(o) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: d Return Value real(kind=wp) Description Compute the arithmetic mean of an array Called By proc~~mean~~CalledByGraph proc~mean mean proc~stdev stdev proc~stdev->proc~mean Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function mean ( d ) result ( o ) !! Compute the arithmetic mean of an array real ( wp ), dimension (:), intent ( in ) :: d real ( wp ) :: o o = sum ( d ) / real ( size ( d ), wp ) end function mean","tags":"","loc":"proc/mean.html","title":"mean – PlPlotLib"},{"text":"public function stdev(d) result(o) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: d Return Value real(kind=wp) Description Compute the standard deviation of an array Calls proc~~stdev~~CallsGraph proc~stdev stdev proc~mean mean proc~stdev->proc~mean Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function stdev ( d ) result ( o ) !! Compute the standard deviation of an array real ( wp ), dimension (:), intent ( in ) :: d real ( wp ) :: o o = sqrt ( sum (( d - mean ( d )) ** 2 ) / real ( size ( d ) - 1 , wp )) end function stdev","tags":"","loc":"proc/stdev.html","title":"stdev – PlPlotLib"},{"text":"public subroutine showProgress(m, p) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: m Message to show real(kind=wp), intent(in) :: p Progress level p\\in[0,1] Description Show a progress bar with a message Calls proc~~showprogress~~CallsGraph proc~showprogress showProgress proc~colorize colorize proc~showprogress->proc~colorize proc~real2char real2char proc~showprogress->proc~real2char Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=wp), public :: r real(kind=wp), public, save :: po integer, public :: N integer, public :: k Source Code subroutine showProgress ( m , p ) !! Show a progress bar with a message character ( * ), intent ( in ) :: m !! Message to show real ( wp ), intent ( in ) :: p !! Progress level p\\in[0,1] real ( wp ) :: r real ( wp ), save :: po integer :: N , k N = 40 if ( p <= 0.0_wp ) then po = p end if if ( p - po < 0.05 . and . p < 1.0_wp ) then return else po = p end if write ( stdout , '(1A)' , advance = 'no' ) achar ( 13 ) // colorize ( m // ' [' ,[ 5 , 5 , 0 ]) do k = 1 , N r = real ( k - 1 , wp ) / real ( N - 1 , wp ) if ( r <= p ) then write ( stdout , '(1A)' , advance = 'no' ) colorize ( '=' , cmap ( r ,[ 0.0_wp , 1.0_wp ])) else write ( stdout , '(1A)' , advance = 'no' ) colorize ( ' ' ,[ 0 , 0 , 0 ]) end if end do write ( stdout , '(1A,1A,1X,1A)' , advance = 'no' ) colorize ( '] ' ,[ 5 , 5 , 0 ]), & & colorize ( real2char ( 10 0.0_wp * p , '1F5.1' ), cmap ( p ,[ 0.0_wp , 1.0_wp ])), & & colorize ( '%' ,[ 5 , 5 , 0 ]) if ( p >= 1.0_wp ) write ( stdout , '(1A)' ) '' flush ( stdout ) end subroutine showProgress","tags":"","loc":"proc/showprogress.html","title":"showProgress – PlPlotLib"},{"text":"public interface mixval Return a 2-vector comprising the minimum and maximum values of an array Called By interface~~mixval~~CalledByGraph interface~mixval mixval proc~scatter scatter proc~scatter->interface~mixval proc~dosurface doSurface proc~dosurface->interface~mixval proc~docontour doContour proc~docontour->interface~mixval program~basic_prg basic_prg program~basic_prg->interface~mixval proc~dofillbetween doFillBetween proc~dofillbetween->interface~mixval proc~dohist doHist proc~dohist->interface~mixval proc~bar bar proc~dohist->proc~bar proc~hist hist proc~dohist->proc~hist proc~dolegend doLegend proc~dolegend->interface~mixval proc~doquiver doQuiver proc~doquiver->interface~mixval proc~quiver quiver proc~doquiver->proc~quiver proc~bar->interface~mixval proc~makelogo makeLogo proc~makelogo->interface~mixval proc~doerror doError proc~doerror->interface~mixval proc~barh barh proc~barh->interface~mixval proc~doplot doPlot proc~doplot->interface~mixval program~animate_prg animate_prg program~animate_prg->interface~mixval proc~dologplot doLogPlot proc~dologplot->interface~mixval proc~hist->interface~mixval proc~hist->proc~bar proc~dobar doBar proc~dobar->interface~mixval proc~dobar->proc~bar proc~dobar->proc~barh proc~quiver->interface~mixval proc~doscatter doScatter proc~doscatter->proc~scatter program~examples_prg examples_prg program~examples_prg->proc~dosurface program~examples_prg->proc~docontour program~examples_prg->proc~dofillbetween program~examples_prg->proc~dohist program~examples_prg->proc~dolegend program~examples_prg->proc~doquiver program~examples_prg->proc~doerror program~examples_prg->proc~doplot program~examples_prg->proc~dologplot program~examples_prg->proc~dobar program~examples_prg->proc~doscatter program~logo_prg logo_prg program~logo_prg->proc~makelogo Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private function mixval_1(x) result(b) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Array to find extrema in Return Value real(kind=wp),\n  dimension(2) Description Return [hi,low] for an array private function mixval_2(x) result(b) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: x Array to find extrema in Return Value real(kind=wp),\n  dimension(2) Description Return [hi,low] for an array private function mixval_3(x) result(b) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: x Array to find extrema in Return Value real(kind=wp),\n  dimension(2) Description Return [hi,low] for an array","tags":"","loc":"interface/mixval.html","title":"mixval – PlPlotLib"},{"text":"public interface span Return a the maximum-minumum values of an array Module Procedures private function span_1(x) result(o) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Array to find span in Return Value real(kind=wp) Description Return hi-low for an array private function span_2(x) result(o) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: x Array to find span in Return Value real(kind=wp) Description Return hi-low for an array private function span_3(x) result(o) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: x Array to find span in Return Value real(kind=wp) Description Return hi-low for an array","tags":"","loc":"interface/span.html","title":"span – PlPlotLib"},{"text":"public interface flatten Reduce an array to one dimension Module Procedures private function flatten_2(A) result(o) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: A Array to convert Return Value real(kind=wp),\n  dimension(:),allocatable Description Convert a 2d array to 1d private function flatten_3(A) result(o) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: A Array to convert Return Value real(kind=wp),\n  dimension(:),allocatable Description Convert a 3d array to 1d","tags":"","loc":"interface/flatten.html","title":"flatten – PlPlotLib"},{"text":"public function binData(d, N, db, normalize) result(o) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: d Data for binning integer, intent(in), optional :: N Number of bins real(kind=wp), intent(in), optional dimension(2) :: db Boundaries of bin range integer, intent(in), optional :: normalize Normalization type (1=sum, 2=bin size, 3=maxval) Return Value real(kind=wp),\n  dimension(:,:),allocatable Description Count data in each bin Calls proc~~bindata~~CallsGraph proc~bindata binData proc~linspace linspace proc~bindata->proc~linspace Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bindata~~CalledByGraph proc~bindata binData proc~dohist doHist proc~dohist->proc~bindata proc~hist hist proc~dohist->proc~hist proc~hist->proc~bindata program~examples_prg examples_prg program~examples_prg->proc~dohist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:), allocatable :: b integer, public :: Nl integer, public :: k Source Code function binData ( d , N , db , normalize ) result ( o ) !! Count data in each bin real ( wp ), dimension (:), intent ( in ) :: d !! Data for binning integer , intent ( in ), optional :: N !! Number of bins real ( wp ), dimension ( 2 ), intent ( in ), optional :: db !! Boundaries of bin range integer , intent ( in ), optional :: normalize !! Normalization type (1=sum, 2=bin size, 3=maxval) real ( wp ), dimension (:,:), allocatable :: o real ( wp ), dimension (:), allocatable :: b integer :: Nl , k Nl = 10 if ( present ( N )) Nl = N if ( present ( db )) then b = linspace ( db ( 1 ), db ( 2 ), Nl + 1 ) else b = linspace ( minval ( d ) - epsilon ( 1.0_wp ), maxval ( d ) + epsilon ( 1.0_wp ), Nl + 1 ) end if allocate ( o ( Nl , 2 )) o (:, 1 ) = ( b ( 1 : Nl ) + b ( 2 : Nl + 1 )) / 2.0_wp do k = 1 , Nl o ( k , 2 ) = real ( count ( d >= b ( k ) . and . d <= b ( k + 1 )), wp ) end do if ( present ( normalize )) then select case ( normalize ) case ( 1 ) o (:, 2 ) = o (:, 2 ) / sum ( o (:, 2 )) case ( 2 ) do k = 1 , Nl o ( k , 2 ) = o ( k , 2 ) / ( b ( k + 1 ) - b ( k )) end do case ( 3 ) o (:, 2 ) = o (:, 2 ) / maxval ( o (:, 2 )) end select end if end function binData","tags":"","loc":"proc/bindata.html","title":"binData – PlPlotLib"},{"text":"public subroutine figure() Arguments None Description Create a new figure Calls proc~~figure~~CallsGraph proc~figure figure pladv pladv proc~figure->pladv plssub plssub proc~figure->plssub pleop pleop proc~figure->pleop plbop plbop proc~figure->plbop Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~figure~~CalledByGraph proc~figure figure proc~dofillbetween doFillBetween proc~dofillbetween->proc~figure proc~dologplot doLogPlot proc~dologplot->proc~figure proc~docontour doContour proc~docontour->proc~figure program~basic_prg basic_prg program~basic_prg->proc~figure program~animate_prg animate_prg program~animate_prg->proc~figure proc~dohist doHist proc~dohist->proc~figure proc~dolegend doLegend proc~dolegend->proc~figure proc~dobar doBar proc~dobar->proc~figure proc~makelogo makeLogo proc~makelogo->proc~figure proc~doerror doError proc~doerror->proc~figure proc~doquiver doQuiver proc~doquiver->proc~figure proc~doplot doPlot proc~doplot->proc~figure proc~doscatter doScatter proc~doscatter->proc~figure proc~dosurface doSurface proc~dosurface->proc~figure program~examples_prg examples_prg program~examples_prg->proc~dofillbetween program~examples_prg->proc~dologplot program~examples_prg->proc~docontour program~examples_prg->proc~dohist program~examples_prg->proc~dolegend program~examples_prg->proc~dobar program~examples_prg->proc~doerror program~examples_prg->proc~doquiver program~examples_prg->proc~doplot program~examples_prg->proc~doscatter program~examples_prg->proc~dosurface program~logo_prg logo_prg program~logo_prg->proc~makelogo Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public, save :: isFirst = .true. Source Code subroutine figure !! Create a new figure logical , save :: isFirst = . true . if (. not . isFirst ) then call pleop () else isFirst = . false . end if call plbop () call plssub ( 1 , 1 ) call pladv ( 1 ) call resetPen () end subroutine figure","tags":"","loc":"proc/figure.html","title":"figure – PlPlotLib"},{"text":"public subroutine subplot(ny, nx, i, aspect, is3d) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ny Number of subplot rows integer, intent(in) :: nx Number of subplot columns integer, intent(in) :: i Subplot to use real(kind=wp), intent(in), optional :: aspect Aspect ratio of the axes logical, intent(in), optional :: is3d Description Create a set of axes on a figure Calls proc~~subplot~~CallsGraph proc~subplot subplot plvsta plvsta proc~subplot->plvsta plssub plssub proc~subplot->plssub plvasp plvasp proc~subplot->plvasp plvpor plvpor proc~subplot->plvpor pladv pladv proc~subplot->pladv Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~subplot~~CalledByGraph proc~subplot subplot proc~dofillbetween doFillBetween proc~dofillbetween->proc~subplot proc~dologplot doLogPlot proc~dologplot->proc~subplot proc~docontour doContour proc~docontour->proc~subplot program~basic_prg basic_prg program~basic_prg->proc~subplot program~animate_prg animate_prg program~animate_prg->proc~subplot proc~dohist doHist proc~dohist->proc~subplot proc~dolegend doLegend proc~dolegend->proc~subplot proc~dobar doBar proc~dobar->proc~subplot proc~makelogo makeLogo proc~makelogo->proc~subplot proc~doerror doError proc~doerror->proc~subplot proc~doquiver doQuiver proc~doquiver->proc~subplot proc~doplot doPlot proc~doplot->proc~subplot proc~doscatter doScatter proc~doscatter->proc~subplot proc~dosurface doSurface proc~dosurface->proc~subplot program~examples_prg examples_prg program~examples_prg->proc~dofillbetween program~examples_prg->proc~dologplot program~examples_prg->proc~docontour program~examples_prg->proc~dohist program~examples_prg->proc~dolegend program~examples_prg->proc~dobar program~examples_prg->proc~doerror program~examples_prg->proc~doquiver program~examples_prg->proc~doplot program~examples_prg->proc~doscatter program~examples_prg->proc~dosurface program~logo_prg logo_prg program~logo_prg->proc~makelogo Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public :: is3dl Source Code subroutine subplot ( ny , nx , i , aspect , is3d ) !! Create a set of axes on a figure integer , intent ( in ) :: nx !! Number of subplot columns integer , intent ( in ) :: ny !! Number of subplot rows integer , intent ( in ) :: i !! Subplot to use real ( wp ), intent ( in ), optional :: aspect !! Aspect ratio of the axes logical , intent ( in ), optional :: is3d logical :: is3dl call plssub ( nx , ny ) call pladv ( i ) call resetPen () is3dl = . false . if ( present ( is3d )) is3dl = is3d if ( is3dl ) then call plvpor ( 0.0_pp , 1.0_pp , 0.0_pp , 1.0_pp ) else if ( present ( aspect )) then call plvasp ( real ( aspect , pp )) else call plvsta () end if end if call defaultLim () end subroutine subplot","tags":"","loc":"proc/subplot.html","title":"subplot – PlPlotLib"},{"text":"public subroutine xylim(xb, yb) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2) :: xb x-range of plot real(kind=wp), intent(in), dimension(2) :: yb y-range of plot Description Set the x and y ranges of the plot Calls proc~~xylim~~CallsGraph proc~xylim xylim plwind plwind proc~xylim->plwind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~xylim~~CalledByGraph proc~xylim xylim proc~dofillbetween doFillBetween proc~dofillbetween->proc~xylim proc~dologplot doLogPlot proc~dologplot->proc~xylim proc~docontour doContour proc~docontour->proc~xylim program~basic_prg basic_prg program~basic_prg->proc~xylim program~animate_prg animate_prg program~animate_prg->proc~xylim proc~dohist doHist proc~dohist->proc~xylim proc~dolegend doLegend proc~dolegend->proc~xylim proc~dobar doBar proc~dobar->proc~xylim proc~makelogo makeLogo proc~makelogo->proc~xylim proc~doquiver doQuiver proc~doquiver->proc~xylim proc~doplot doPlot proc~doplot->proc~xylim proc~doscatter doScatter proc~doscatter->proc~xylim proc~doerror doError proc~doerror->proc~xylim program~examples_prg examples_prg program~examples_prg->proc~dofillbetween program~examples_prg->proc~dologplot program~examples_prg->proc~docontour program~examples_prg->proc~dohist program~examples_prg->proc~dolegend program~examples_prg->proc~dobar program~examples_prg->proc~doquiver program~examples_prg->proc~doplot program~examples_prg->proc~doscatter program~examples_prg->proc~doerror program~logo_prg logo_prg program~logo_prg->proc~makelogo Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pp), public, dimension(2) :: xbl real(kind=pp), public, dimension(2) :: ybl Source Code subroutine xylim ( xb , yb ) !! Set the x and y ranges of the plot real ( wp ), dimension ( 2 ), intent ( in ) :: xb !! x-range of plot real ( wp ), dimension ( 2 ), intent ( in ) :: yb !! y-range of plot real ( pp ), dimension ( 2 ) :: xbl , ybl xbl = localize ( xb ) ybl = localize ( yb ) call plwind ( xbl ( 1 ), xbl ( 2 ), ybl ( 1 ), ybl ( 2 )) end subroutine xylim","tags":"","loc":"proc/xylim.html","title":"xylim – PlPlotLib"},{"text":"public subroutine xlim(xl, xh) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xl real(kind=wp), intent(in) :: xh Description Set the limits of the x-axis Calls proc~~xlim~~CallsGraph proc~xlim xlim plgvpw plgvpw proc~xlim->plgvpw plwind plwind proc~xlim->plwind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pp), public :: x1 real(kind=pp), public :: x2 real(kind=pp), public :: y1 real(kind=pp), public :: y2 Source Code subroutine xlim ( xl , xh ) !! Set the limits of the x-axis real ( wp ), intent ( in ) :: xl , xh real ( pp ) :: x1 , x2 , y1 , y2 call plgvpw ( x1 , x2 , y1 , y2 ) call plwind ( real ( xl , pp ), real ( xh , pp ), y1 , y2 ) end subroutine xlim","tags":"","loc":"proc/xlim.html","title":"xlim – PlPlotLib"},{"text":"public subroutine ylim(yl, yh) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: yl real(kind=wp), intent(in) :: yh Description Set the limits of the y-axis Calls proc~~ylim~~CallsGraph proc~ylim ylim plgvpw plgvpw proc~ylim->plgvpw plwind plwind proc~ylim->plwind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pp), public :: x1 real(kind=pp), public :: x2 real(kind=pp), public :: y1 real(kind=pp), public :: y2 Source Code subroutine ylim ( yl , yh ) !! Set the limits of the y-axis real ( wp ), intent ( in ) :: yl , yh real ( pp ) :: x1 , x2 , y1 , y2 call plgvpw ( x1 , x2 , y1 , y2 ) call plwind ( x1 , x2 , real ( yl , pp ), real ( yh , pp )) end subroutine ylim","tags":"","loc":"proc/ylim.html","title":"ylim – PlPlotLib"},{"text":"public subroutine xyzlim(xb, yb, zb, altitude, azimuth, zoom) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2) :: xb x-range of plot real(kind=wp), intent(in), dimension(2) :: yb y-range of plot real(kind=wp), intent(in), dimension(2) :: zb z-range of plot real(kind=wp), intent(in), optional :: altitude Altitude angle of plot in degrees real(kind=wp), intent(in), optional :: azimuth Azimuth angle of plot in degrees real(kind=wp), intent(in), optional :: zoom Zoom ratio (default 1.0) Description Set the limits for a 3d plot Calls proc~~xyzlim~~CallsGraph proc~xyzlim xyzlim plw3d plw3d proc~xyzlim->plw3d plwind plwind proc~xyzlim->plwind Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~xyzlim~~CalledByGraph proc~xyzlim xyzlim proc~dosurface doSurface proc~dosurface->proc~xyzlim program~examples_prg examples_prg program~examples_prg->proc~dosurface Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pp), public :: al real(kind=pp), public :: az real(kind=pp), public :: zm Source Code subroutine xyzlim ( xb , yb , zb , altitude , azimuth , zoom ) !! Set the limits for a 3d plot real ( wp ), dimension ( 2 ), intent ( in ) :: xb !! x-range of plot real ( wp ), dimension ( 2 ), intent ( in ) :: yb !! y-range of plot real ( wp ), dimension ( 2 ), intent ( in ) :: zb !! z-range of plot real ( wp ), intent ( in ), optional :: altitude !! Altitude angle of plot in degrees real ( wp ), intent ( in ), optional :: azimuth !! Azimuth angle of plot in degrees real ( wp ), intent ( in ), optional :: zoom !! Zoom ratio (default 1.0) real ( pp ) :: al , az , zm al = 4 5.0_pp if ( present ( altitude )) al = real ( altitude , pp ) az = 6 0.0_pp if ( present ( azimuth )) az = real ( azimuth , pp ) zm = 1.0_pp if ( present ( zoom )) zm = real ( zoom , pp ) call plwind ( - 1.0_pp , 1.0_pp , - 1.0_pp , 1.5_pp ) call plw3d ( zm , zm , 1.2_pp * zm , & & real ( xb ( 1 ), pp ), real ( xb ( 2 ), pp ), & & real ( yb ( 1 ), pp ), real ( yb ( 2 ), pp ), & & real ( zb ( 1 ), pp ), real ( zb ( 2 ), pp ), al , az ) end subroutine xyzlim","tags":"","loc":"proc/xyzlim.html","title":"xyzlim – PlPlotLib"},{"text":"public subroutine ticks(dx, dy, logx, logy, color, linewidth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), optional :: dx Spacing between ticks on x-axis real(kind=wp), intent(in), optional :: dy Spacing between ticks on y-axis logical, intent(in), optional :: logx Flag for log-ticks and labels on x-axis logical, intent(in), optional :: logy Flag for log-ticks and labels on y-axis character(len=*), intent(in), optional :: color Color code for ticks, box, and labels real(kind=wp) , optional :: linewidth Line width for ticks and box Description Set the ticks for the axes Calls proc~~ticks~~CallsGraph proc~ticks ticks plbox plbox proc~ticks->plbox Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~ticks~~CalledByGraph proc~ticks ticks proc~dofillbetween doFillBetween proc~dofillbetween->proc~ticks proc~dologplot doLogPlot proc~dologplot->proc~ticks proc~docontour doContour proc~docontour->proc~ticks program~basic_prg basic_prg program~basic_prg->proc~ticks program~animate_prg animate_prg program~animate_prg->proc~ticks proc~dohist doHist proc~dohist->proc~ticks proc~dolegend doLegend proc~dolegend->proc~ticks proc~doscatter doScatter proc~doscatter->proc~ticks proc~makelogo makeLogo proc~makelogo->proc~ticks proc~doquiver doQuiver proc~doquiver->proc~ticks proc~dobar doBar proc~dobar->proc~ticks proc~doerror doError proc~doerror->proc~ticks program~examples_prg examples_prg program~examples_prg->proc~dofillbetween program~examples_prg->proc~dologplot program~examples_prg->proc~docontour program~examples_prg->proc~dohist program~examples_prg->proc~dolegend program~examples_prg->proc~doscatter program~examples_prg->proc~doquiver program~examples_prg->proc~dobar program~examples_prg->proc~doerror program~logo_prg logo_prg program~logo_prg->proc~makelogo Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pp), public :: dxl real(kind=pp), public :: dyl character(len=10), public :: xopts character(len=10), public :: yopts Source Code subroutine ticks ( dx , dy , logx , logy , color , lineWidth ) !! Set the ticks for the axes real ( wp ), intent ( in ), optional :: dx !! Spacing between ticks on x-axis real ( wp ), intent ( in ), optional :: dy !! Spacing between ticks on y-axis logical , intent ( in ), optional :: logx !! Flag for log-ticks and labels on x-axis logical , intent ( in ), optional :: logy !! Flag for log-ticks and labels on y-axis character ( * ), intent ( in ), optional :: color !! Color code for ticks, box, and labels real ( wp ), optional :: linewidth !! Line width for ticks and box real ( pp ) :: dxl , dyl character ( 10 ) :: xopts , yopts dxl = 0.0_pp if ( present ( dx )) dxl = real ( dx , pp ) dyl = 0.0_pp if ( present ( dy )) dyl = real ( dy , pp ) xopts = 'bcnst' if ( present ( logx )) then if ( logx ) xopts = 'bcnstl' end if yopts = 'bcnstv' if ( present ( logy )) then if ( logy ) yopts = 'bcnstvl' end if call resetPen () if ( present ( color )) call setColor ( color ) if ( present ( lineWidth )) call setLineWidth ( lineWidth ) call plbox ( xopts , dxl , 0 , yopts , dyl , 0 ) call resetPen () end subroutine ticks","tags":"","loc":"proc/ticks.html","title":"ticks – PlPlotLib"},{"text":"public subroutine box(xLabel, yLabel, zLabel, color) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: xLabel Label for x-axis character(len=*), intent(in) :: yLabel Label for x-axis character(len=*), intent(in) :: zLabel Label for z-axis character(len=*), intent(in), optional :: color Color of labels Description Set x,y and plot labels Calls proc~~box~~CallsGraph proc~box box plbox3 plbox3 proc~box->plbox3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~box~~CalledByGraph proc~box box proc~dosurface doSurface proc~dosurface->proc~box program~examples_prg examples_prg program~examples_prg->proc~dosurface Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine box ( xLabel , yLabel , zLabel , color ) !! Set x,y and plot labels character ( * ), intent ( in ) :: xLabel !! Label for x-axis character ( * ), intent ( in ) :: yLabel !! Label for x-axis character ( * ), intent ( in ) :: zLabel !! Label for z-axis character ( * ), intent ( in ), optional :: color !! Color of labels if ( present ( color )) call setColor ( color ) call plbox3 ( 'bnstu' , xLabel , 0.0_pp , 0 , 'bnstu' , yLabel , 0.0_pp , 0 , 'bnstu' , zLabel , 0.0_pp , 0 ) call resetPen () end subroutine box","tags":"","loc":"proc/box.html","title":"box – PlPlotLib"},{"text":"public subroutine xticks(d, logScale, primary, secondary, color, linewidth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), optional :: d Spacing between ticks logical, intent(in), optional :: logScale Flag for log-ticks and labels logical, intent(in), optional :: primary Draw primary axis logical, intent(in), optional :: secondary Draw secondary axis character(len=*), intent(in), optional :: color Color code for ticks, box, and labels real(kind=wp) , optional :: linewidth Line width for ticks and box Description Set the ticks for the x-axis Calls proc~~xticks~~CallsGraph proc~xticks xticks plbox plbox proc~xticks->plbox Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~xticks~~CalledByGraph proc~xticks xticks proc~doplot doPlot proc~doplot->proc~xticks program~examples_prg examples_prg program~examples_prg->proc~doplot Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pp), public :: dxl real(kind=pp), public :: dyl character(len=10), public :: xopts character(len=10), public :: yopts Source Code subroutine xticks ( d , logScale , primary , secondary , color , lineWidth ) !! Set the ticks for the x-axis real ( wp ), intent ( in ), optional :: d !! Spacing between ticks logical , intent ( in ), optional :: logScale !! Flag for log-ticks and labels logical , intent ( in ), optional :: primary !! Draw primary axis logical , intent ( in ), optional :: secondary !! Draw secondary axis character ( * ), intent ( in ), optional :: color !! Color code for ticks, box, and labels real ( wp ), optional :: linewidth !! Line width for ticks and box real ( pp ) :: dxl , dyl character ( 10 ) :: xopts , yopts dxl = 0.0_pp dyl = 0.0_pp if ( present ( d )) dxl = real ( d , pp ) xopts = 'nst' if ( present ( primary )) then if ( primary ) xopts = trim ( xopts ) // 'b' else xopts = trim ( xopts ) // 'b' end if if ( present ( secondary )) then if ( secondary ) xopts = trim ( xopts ) // 'c' else xopts = trim ( xopts ) // 'c' end if if ( present ( logScale )) then if ( logScale ) xopts = trim ( xopts ) // 'l' end if yopts = '' if ( present ( color )) call setColor ( color ) if ( present ( lineWidth )) call setLineWidth ( lineWidth ) call plbox ( xopts , dxl , 0 , yopts , dyl , 0 ) call resetPen () end subroutine xticks","tags":"","loc":"proc/xticks.html","title":"xticks – PlPlotLib"},{"text":"public subroutine yticks(d, logScale, primary, secondary, color, linewidth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), optional :: d Spacing between ticks logical, intent(in), optional :: logScale Flag for log-ticks and labels logical, intent(in), optional :: primary Draw primary axis logical, intent(in), optional :: secondary Draw secondary axis character(len=*), intent(in), optional :: color Color code for ticks, box, and labels real(kind=wp) , optional :: linewidth Line width for ticks and box Description Set the ticks for the y-axis Calls proc~~yticks~~CallsGraph proc~yticks yticks plbox plbox proc~yticks->plbox Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~yticks~~CalledByGraph proc~yticks yticks proc~doplot doPlot proc~doplot->proc~yticks program~examples_prg examples_prg program~examples_prg->proc~doplot Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pp), public :: dxl real(kind=pp), public :: dyl character(len=10), public :: xopts character(len=10), public :: yopts Source Code subroutine yticks ( d , logScale , primary , secondary , color , lineWidth ) !! Set the ticks for the y-axis real ( wp ), intent ( in ), optional :: d !! Spacing between ticks logical , intent ( in ), optional :: logScale !! Flag for log-ticks and labels logical , intent ( in ), optional :: primary !! Draw primary axis logical , intent ( in ), optional :: secondary !! Draw secondary axis character ( * ), intent ( in ), optional :: color !! Color code for ticks, box, and labels real ( wp ), optional :: linewidth !! Line width for ticks and box real ( pp ) :: dxl , dyl character ( 10 ) :: xopts , yopts dxl = 0.0_pp dyl = 0.0_pp if ( present ( d )) dyl = real ( d , pp ) yopts = 'nst' if ( present ( primary )) then if ( primary ) yopts = trim ( xopts ) // 'b' else yopts = trim ( yopts ) // 'b' end if if ( present ( secondary )) then if ( secondary ) yopts = trim ( yopts ) // 'c' else yopts = trim ( yopts ) // 'c' end if if ( present ( logScale )) then if ( logScale ) yopts = trim ( yopts ) // 'l' end if xopts = '' if ( present ( color )) call setColor ( color ) if ( present ( lineWidth )) call setLineWidth ( lineWidth ) call plbox ( xopts , dxl , 0 , yopts , dyl , 0 ) call resetPen () end subroutine yticks","tags":"","loc":"proc/yticks.html","title":"yticks – PlPlotLib"},{"text":"public subroutine labels(xLabel, yLabel, plotLabel, color) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: xLabel Label for x-axis character(len=*), intent(in) :: yLabel Label for x-axis character(len=*), intent(in) :: plotLabel Label entire plot character(len=*), intent(in), optional :: color Color of labels Description Set x,y and plot labels Calls proc~~labels~~CallsGraph proc~labels labels pllab pllab proc~labels->pllab Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~labels~~CalledByGraph proc~labels labels proc~dofillbetween doFillBetween proc~dofillbetween->proc~labels proc~dologplot doLogPlot proc~dologplot->proc~labels proc~docontour doContour proc~docontour->proc~labels program~basic_prg basic_prg program~basic_prg->proc~labels program~animate_prg animate_prg program~animate_prg->proc~labels proc~dolegend doLegend proc~dolegend->proc~labels proc~doscatter doScatter proc~doscatter->proc~labels proc~makelogo makeLogo proc~makelogo->proc~labels proc~doquiver doQuiver proc~doquiver->proc~labels proc~dobar doBar proc~dobar->proc~labels proc~doerror doError proc~doerror->proc~labels program~examples_prg examples_prg program~examples_prg->proc~dofillbetween program~examples_prg->proc~dologplot program~examples_prg->proc~docontour program~examples_prg->proc~dolegend program~examples_prg->proc~doscatter program~examples_prg->proc~doquiver program~examples_prg->proc~dobar program~examples_prg->proc~doerror program~logo_prg logo_prg program~logo_prg->proc~makelogo Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine labels ( xLabel , yLabel , plotLabel , color ) !! Set x,y and plot labels character ( * ), intent ( in ) :: xLabel !! Label for x-axis character ( * ), intent ( in ) :: yLabel !! Label for x-axis character ( * ), intent ( in ) :: plotLabel !! Label entire plot character ( * ), intent ( in ), optional :: color !! Color of labels if ( present ( color )) call setColor ( color ) call pllab ( xLabel , yLabel , plotLabel ) call resetPen () end subroutine labels","tags":"","loc":"proc/labels.html","title":"labels – PlPlotLib"},{"text":"public subroutine xlabel(label, color) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label Label for axis character(len=*), intent(in), optional :: color Color of labels Description Set x-label Calls proc~~xlabel~~CallsGraph proc~xlabel xlabel plmtex plmtex proc~xlabel->plmtex Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~xlabel~~CalledByGraph proc~xlabel xlabel proc~doplot doPlot proc~doplot->proc~xlabel program~examples_prg examples_prg program~examples_prg->proc~doplot Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine xlabel ( label , color ) !! Set x-label character ( * ), intent ( in ) :: label !! Label for axis character ( * ), intent ( in ), optional :: color !! Color of labels if ( present ( color )) call setColor ( color ) call plmtex ( 'b' , 3.0_pp , 0.5_pp , 0.5_pp , label ) call resetPen () end subroutine xlabel","tags":"","loc":"proc/xlabel.html","title":"xlabel – PlPlotLib"},{"text":"public subroutine ylabel(label, color) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label Label for axis character(len=*), intent(in), optional :: color Color of labels Description Set y-label Calls proc~~ylabel~~CallsGraph proc~ylabel ylabel plmtex plmtex proc~ylabel->plmtex Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~ylabel~~CalledByGraph proc~ylabel ylabel proc~doplot doPlot proc~doplot->proc~ylabel program~examples_prg examples_prg program~examples_prg->proc~doplot Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine ylabel ( label , color ) !! Set y-label character ( * ), intent ( in ) :: label !! Label for axis character ( * ), intent ( in ), optional :: color !! Color of labels if ( present ( color )) call setColor ( color ) call plmtex ( 'l' , 5.0_pp , 0.5_pp , 0.5_pp , label ) call resetPen () end subroutine ylabel","tags":"","loc":"proc/ylabel.html","title":"ylabel – PlPlotLib"},{"text":"public subroutine title(label, color) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label Label for plot character(len=*), intent(in), optional :: color Color of labels Description Set plot title Calls proc~~title~~CallsGraph proc~title title plmtex plmtex proc~title->plmtex Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~title~~CalledByGraph proc~title title proc~doplot doPlot proc~doplot->proc~title program~examples_prg examples_prg program~examples_prg->proc~doplot Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine title ( label , color ) !! Set plot title character ( * ), intent ( in ) :: label !! Label for plot character ( * ), intent ( in ), optional :: color !! Color of labels if ( present ( color )) call setColor ( color ) call plmtex ( 't' , 1.5_pp , 0.5_pp , 0.5_pp , label ) call resetPen () end subroutine title","tags":"","loc":"proc/title.html","title":"title – PlPlotLib"},{"text":"public subroutine colorbar(z, N, leftLabel, rightLabel) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: z Data used for levels computation integer, intent(in) :: N Number of levels to compute character(len=*), intent(in), optional :: leftLabel Label for left side of colorbar character(len=*), intent(in), optional :: rightLabel Label for right side of colorbar Description Add a colorbar to the top of the plot Calls proc~~colorbar~~CallsGraph proc~colorbar colorbar plcolorbar plcolorbar proc~colorbar->plcolorbar Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~colorbar~~CalledByGraph proc~colorbar colorbar proc~docontour doContour proc~docontour->proc~colorbar proc~doquiver doQuiver proc~doquiver->proc~colorbar program~examples_prg examples_prg program~examples_prg->proc~docontour program~examples_prg->proc~doquiver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pp), public, dimension(:,:), allocatable :: values character(len=64), public, dimension(2) :: labels real(kind=pp), public :: fill_width real(kind=pp), public :: cont_width integer, public :: cont_color real(kind=pp), public :: colorbar_width real(kind=pp), public :: colorbar_height integer, public :: k Source Code subroutine colorbar ( z , N , leftLabel , rightLabel ) !! Add a colorbar to the top of the plot real ( wp ), dimension (:,:), intent ( in ) :: z !! Data used for levels computation integer , intent ( in ) :: N !! Number of levels to compute character ( * ), intent ( in ), optional :: leftLabel !! Label for left side of colorbar character ( * ), intent ( in ), optional :: rightLabel !! Label for right side of colorbar real ( pp ), dimension (:,:), allocatable :: values character ( 64 ), dimension ( 2 ) :: labels real ( pp ) :: fill_width real ( pp ) :: cont_width integer :: cont_color real ( pp ) :: colorbar_width real ( pp ) :: colorbar_height integer :: k values = reshape ( & & real ([( real ( k - 1 , wp ) / real ( N - 1 , wp ) * ( maxval ( z ) - minval ( z )) + minval ( z ) , k = 1 , N )], pp ), & & [ N , 1 ]) fill_width = 2.0_pp cont_width = 0.0_pp cont_color = 1 labels = '' if ( present ( leftLabel )) labels ( 1 ) = leftLabel if ( present ( rightLabel )) labels ( 2 ) = rightLabel call plcolorbar ( colorbar_width , colorbar_height ,& & ior ( PL_COLORBAR_GRADIENT , PL_COLORBAR_SHADE_LABEL ), PL_POSITION_TOP ,& & 0.0_pp , 0.01_pp , 0.75_pp , 0.05_pp ,& & 0 , 1 , 1 , 0.0_pp , 0.0_pp , & & cont_color , cont_width , & & [ PL_COLORBAR_LABEL_LEFT , PL_COLORBAR_LABEL_RIGHT ], labels , & & [ 'bcvmt' ],[ 0.0_pp ],[ 0 ],[ size ( values )], values ) end subroutine colorbar","tags":"","loc":"proc/colorbar.html","title":"colorbar – PlPlotLib"},{"text":"public subroutine colorbar2(z, N, leftLabel, rightLabel) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: z Data used for levels computation integer, intent(in) :: N Number of levels to compute character(len=*), intent(in), optional :: leftLabel Label for left side of colorbar character(len=*), intent(in), optional :: rightLabel Label for right side of colorbar Description Add a colorbar to the top of the plot Calls proc~~colorbar2~~CallsGraph proc~colorbar2 colorbar2 plcolorbar plcolorbar proc~colorbar2->plcolorbar Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pp), public, dimension(:,:), allocatable :: values character(len=64), public, dimension(2) :: labels real(kind=pp), public :: fill_width real(kind=pp), public :: cont_width integer, public :: cont_color real(kind=pp), public :: colorbar_width real(kind=pp), public :: colorbar_height integer, public :: k Source Code subroutine colorbar2 ( z , N , leftLabel , rightLabel ) !! Add a colorbar to the top of the plot real ( wp ), dimension (:,:), intent ( in ) :: z !! Data used for levels computation integer , intent ( in ) :: N !! Number of levels to compute character ( * ), intent ( in ), optional :: leftLabel !! Label for left side of colorbar character ( * ), intent ( in ), optional :: rightLabel !! Label for right side of colorbar real ( pp ), dimension (:,:), allocatable :: values character ( 64 ), dimension ( 2 ) :: labels real ( pp ) :: fill_width real ( pp ) :: cont_width integer :: cont_color real ( pp ) :: colorbar_width real ( pp ) :: colorbar_height integer :: k values = reshape ( & & real ([( real ( k - 1 , wp ) / real ( N - 1 , wp ) * ( maxval ( z ) - minval ( z )) + minval ( z ) , k = 1 , N )], pp ), & & [ N , 1 ]) fill_width = 2.0_pp cont_width = 0.0_pp cont_color = 1 labels = '' if ( present ( leftLabel )) labels ( 1 ) = leftLabel if ( present ( rightLabel )) labels ( 2 ) = rightLabel call plcolorbar ( colorbar_width , colorbar_height ,& & ior ( PL_COLORBAR_GRADIENT , PL_COLORBAR_SHADE_LABEL ), PL_POSITION_RIGHT ,& & 0.01_pp , 0.0_pp , 0.05_pp , 0.75_pp ,& & 0 , 1 , 1 , 0.0_pp , 0.0_pp , & & cont_color , cont_width , & & [ PL_COLORBAR_LABEL_BOTTOM , PL_COLORBAR_LABEL_TOP ], labels , & & [ 'bcvmt' ],[ 0.0_pp ],[ 0 ],[ size ( values )], values ) end subroutine colorbar2","tags":"","loc":"proc/colorbar2.html","title":"colorbar2 – PlPlotLib"},{"text":"public subroutine legend(corner, series, lineWidths, markScales, markCounts, ncol) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: corner Corner for legend character(len=*), intent(in), dimension(:,:) :: series Data series in rows\n [name,textColor,lineStyle,lineColor,markStyle,markColor,boxColor] real(kind=wp), intent(in), optional dimension(:) :: lineWidths Line widths for the plots real(kind=wp), intent(in), optional dimension(:) :: markScales Marker sizes for the plots integer, intent(in), optional dimension(:) :: markCounts Marker counts for the plots integer, intent(in), optional :: ncol Number of columns Description Create legend for plot data FIXME: Text sizing should be modifiable Calls proc~~legend~~CallsGraph proc~legend legend none~doboxes doBoxes proc~legend->none~doboxes none~dolines doLines proc~legend->none~dolines none~dolegendbox doLegendBox proc~legend->none~dolegendbox none~domarkers doMarkers proc~legend->none~domarkers pllegend pllegend proc~legend->pllegend none~dotext doText proc~legend->none~dotext series series none~doboxes->series none~dolines->series none~getcorner getCorner none~dolegendbox->none~getcorner none~domarkers->series none~dotext->series proc~startswith startsWith none~getcorner->proc~startswith proc~endswith endsWith none~getcorner->proc~endswith Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~legend~~CalledByGraph proc~legend legend proc~dolegend doLegend proc~dolegend->proc~legend program~examples_prg examples_prg program~examples_prg->proc~dolegend Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pp), public :: width real(kind=pp), public :: height real(kind=pp), public :: xoff real(kind=pp), public :: yoff real(kind=pp), public :: plotWidth integer, public :: opt integer, public :: cornerl integer, public :: bg_color integer, public :: bb_color integer, public :: bb_style integer, public :: lncol integer, public :: lnrow integer, public, dimension(size(series,1)) :: opts real(kind=pp), public, dimension(size(series,1)) :: lwidths real(kind=pp), public, dimension(size(series,1)) :: mscales integer, public, dimension(size(series,1)) :: mcounts integer, public, dimension(size(series,1)) :: text_colors real(kind=pp), public :: text_offset real(kind=pp), public :: text_scale real(kind=pp), public :: text_spacing real(kind=pp), public :: text_justification integer, public, dimension(size(series,1)) :: box_colors integer, public, dimension(size(series,1)) :: box_patterns real(kind=pp), public, dimension(size(series,1)) :: box_scales real(kind=pp), public, dimension(size(series,1)) :: box_line_widths integer, public, dimension(size(series,1)) :: line_colors integer, public, dimension(size(series,1)) :: line_styles integer, public, dimension(size(series,1)) :: mark_colors character(len=64), public, dimension(size(series,1)) :: mark_styles integer, public :: k Functions function getCorner(text) result(code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: text Return Value integer Subroutines subroutine doLegendBox() Arguments None subroutine doText() Arguments None subroutine doBoxes() Arguments None subroutine doLines() Arguments None subroutine doMarkers() Arguments None Source Code subroutine legend ( corner , series , lineWidths , markScales , markCounts , ncol ) !! Create legend for plot data !! !! FIXME: Text sizing should be modifiable character ( * ), intent ( in ) :: corner !! Corner for legend character ( * ), dimension (:,:), intent ( in ) :: series !! Data series in rows !! [name,textColor,lineStyle,lineColor,markStyle,markColor,boxColor] real ( wp ), dimension (:), intent ( in ), optional :: lineWidths !! Line widths for the plots real ( wp ), dimension (:), intent ( in ), optional :: markScales !! Marker sizes for the plots integer , dimension (:), intent ( in ), optional :: markCounts !! Marker counts for the plots integer , intent ( in ), optional :: ncol !! Number of columns real ( pp ) :: width , height , xoff , yoff real ( pp ) :: plotWidth integer :: opt , cornerl integer :: bg_color , bb_color , bb_style , lncol , lnrow integer , dimension ( size ( series , 1 )) :: opts real ( pp ), dimension ( size ( series , 1 )) :: lwidths , mscales integer , dimension ( size ( series , 1 )) :: mcounts , text_colors real ( pp ) :: text_offset , text_scale , text_spacing , text_justification integer , dimension ( size ( series , 1 )) :: box_colors , box_patterns real ( pp ), dimension ( size ( series , 1 )) :: box_scales , box_line_widths integer , dimension ( size ( series , 1 )) :: line_colors , line_styles integer , dimension ( size ( series , 1 )) :: mark_colors character ( 64 ), dimension ( size ( series , 1 )) :: mark_styles integer :: k call doLegendBox () opts = 0 do k = 1 , size ( series , 1 ) if ( series ( k , 3 ) /= '' ) opts ( k ) = ior ( opts ( k ), PL_LEGEND_LINE ) if ( series ( k , 5 ) /= '' ) opts ( k ) = ior ( opts ( k ), PL_LEGEND_SYMBOL ) if ( series ( k , 7 ) /= '' ) opts ( k ) = ior ( opts ( k ), PL_LEGEND_COLOR_BOX ) end do call doText () call doBoxes () call doLines () call doMarkers () call pllegend ( width , height , opt , cornerl , xoff , yoff , plotWidth , & & bg_color , bb_color , bb_style , & & lnrow , lncol , size ( series , 1 ), opts , text_offset , & & text_scale , text_spacing , text_justification , text_colors , series (:, 1 ), & & box_colors , box_patterns , box_scales , box_line_widths , & & line_colors , line_styles , lwidths , & & mark_colors , mscales , mcounts , mark_styles ) contains subroutine doLegendBox opt = PL_LEGEND_BACKGROUND + PL_LEGEND_BOUNDING_BOX cornerl = getCorner ( corner ) xoff = 0.0_pp yoff = 0.0_pp plotWidth = 0.05_pp bg_color = 0 bb_color = 1 bb_style = getLineStyleCode ( '-' ) lncol = 1 if ( present ( ncol )) lncol = ncol lnrow = size ( series , 1 ) / lncol end subroutine doLegendBox subroutine doText text_offset = 0.3_pp text_scale = fontScale text_spacing = 3.0_pp text_justification = 0.0_pp do k = 1 , size ( series , 1 ) text_colors = getColorCode ( series ( k , 2 )) end do end subroutine doText subroutine doBoxes do k = 1 , size ( series , 1 ) box_colors ( k ) = getColorCode ( series ( k , 7 )) end do box_patterns = 0 box_scales = 0.5_pp box_line_widths = 0.0_pp end subroutine doBoxes subroutine doLines lwidths = 1.0_pp if ( present ( lineWidths )) lwidths = real ( lineWidths , pp ) do k = 1 , size ( series , 1 ) line_colors ( k ) = getColorCode ( series ( k , 4 )) line_styles ( k ) = getLineStyleCode ( series ( k , 3 )) end do end subroutine doLines subroutine doMarkers mcounts = 2 if ( present ( markCounts )) mcounts = markCounts mscales = 1.0_pp if ( present ( markScales )) mscales = real ( markScales , pp ) do k = 1 , size ( series , 1 ) mark_colors ( k ) = getColorCode ( series ( k , 6 )) mark_styles ( k ) = getSymbolCode ( series ( k , 5 )) end do end subroutine doMarkers function getCorner ( text ) result ( code ) character ( * ), intent ( in ) :: text integer :: code code = PL_POSITION_INSIDE if ( startsWith ( text , 'upper' ) ) code = code + PL_POSITION_TOP if ( startsWith ( text , 'lower' ) ) code = code + PL_POSITION_BOTTOM if ( endsWith ( text , 'right' ) ) code = code + PL_POSITION_RIGHT if ( endsWith ( text , 'left' ) ) code = code + PL_POSITION_LEFT end function getCorner end subroutine legend","tags":"","loc":"proc/legend.html","title":"legend – PlPlotLib"},{"text":"public subroutine hist(d, N, db, relWidth, fillColor, fillPattern, lineColor, lineWidth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: d Data for binning integer, intent(in), optional :: N Number of bins real(kind=wp), intent(in), optional dimension(2) :: db Boundaries of bin range real(kind=wp), intent(in), optional :: relWidth Relative width of bars (default 0.8) character(len=*), intent(in), optional :: fillColor Color of bar fills character(len=*), intent(in), optional :: fillPattern Pattern of bar fills character(len=*), intent(in), optional :: lineColor Color of lines around bars real(kind=wp) , optional :: lineWidth Width of lines around bars Description Create a histogram Calls proc~~hist~~CallsGraph proc~hist hist interface~mixval mixval proc~hist->interface~mixval proc~bar bar proc~hist->proc~bar proc~bindata binData proc~hist->proc~bindata proc~bar->interface~mixval plline plline proc~bar->plline plfill plfill proc~bar->plfill plcol1 plcol1 proc~bar->plcol1 proc~linspace linspace proc~bindata->proc~linspace Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~hist~~CalledByGraph proc~hist hist proc~dohist doHist proc~dohist->proc~hist program~examples_prg examples_prg program~examples_prg->proc~dohist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:,:), allocatable :: h real(kind=wp), public, dimension(2) :: dbl integer, public :: Nl real(kind=wp), public :: relWidthl real(kind=wp), public :: lineWidthl Source Code subroutine hist ( d , N , db , relWidth , fillColor , fillPattern , lineColor , lineWidth ) !! Create a histogram real ( wp ), dimension (:), intent ( in ) :: d !! Data for binning integer , intent ( in ), optional :: N !! Number of bins real ( wp ), dimension ( 2 ), intent ( in ), optional :: db !! Boundaries of bin range real ( wp ), intent ( in ), optional :: relWidth !! Relative width of bars (default 0.8) character ( * ), intent ( in ), optional :: fillColor !! Color of bar fills character ( * ), intent ( in ), optional :: fillPattern !! Pattern of bar fills character ( * ), intent ( in ), optional :: lineColor !! Color of lines around bars real ( wp ), optional :: lineWidth !! Width of lines around bars real ( wp ), dimension (:,:), allocatable :: h real ( wp ), dimension ( 2 ) :: dbl integer :: Nl real ( wp ) :: relWidthl real ( wp ) :: lineWidthl Nl = 20 if ( present ( N )) Nl = N if ( present ( db )) then dbl = db else dbl = mixval ( d ) + [ - 1.0_wp , 1.0_wp ] * epsilon ( 1.0_wp ) end if h = binData ( d , Nl , dbl , normalize = 3 ) relWidthl = 1.0_wp if ( present ( relWidth )) relWidthl = relWidth lineWidthl = 0.5_wp if ( present ( lineWidth )) lineWidthl = lineWidth if ( present ( lineColor )) then if ( present ( fillColor )) then if ( present ( fillPattern )) then call bar ( h (:, 1 ), h (:, 2 ), relWidth = relWidthl , lineColor = lineColor , lineWidth = lineWidthl , & & fillColor = fillColor , fillPattern = fillPattern ) else call bar ( h (:, 1 ), h (:, 2 ), relWidth = relWidthl , lineColor = lineColor , lineWidth = lineWidthl , & & fillColor = fillColor ) end if else if ( present ( fillPattern )) then call bar ( h (:, 1 ), h (:, 2 ), h (:, 2 ), relWidth = relWidthl , lineColor = lineColor , lineWidth = lineWidthl , & & fillPattern = fillPattern ) else call bar ( h (:, 1 ), h (:, 2 ), h (:, 2 ), relWidth = relWidthl , lineColor = lineColor , lineWidth = lineWidthl ) end if end if else if ( present ( fillColor )) then if ( present ( fillPattern )) then call bar ( h (:, 1 ), h (:, 2 ), relWidth = relWidthl , lineWidth = lineWidthl , & & fillColor = fillColor , fillPattern = fillPattern ) else call bar ( h (:, 1 ), h (:, 2 ), relWidth = relWidthl , lineWidth = lineWidthl , & & fillColor = fillColor ) end if else if ( present ( fillPattern )) then call bar ( h (:, 1 ), h (:, 2 ), h (:, 2 ), relWidth = relWidthl , lineWidth = lineWidthl , & & fillPattern = fillPattern ) else call bar ( h (:, 1 ), h (:, 2 ), h (:, 2 ), relWidth = relWidthl , lineWidth = lineWidthl ) end if end if end if call resetPen () end subroutine hist","tags":"","loc":"proc/hist.html","title":"hist – PlPlotLib"},{"text":"public subroutine scatter(x, y, c, s, markColor, markStyle, markSize) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x x-coordinates of data real(kind=wp), intent(in), dimension(:) :: y y-coordinates of data real(kind=wp), intent(in), optional dimension(:) :: c Data for smooth coloring real(kind=wp), intent(in), optional dimension(:) :: s Data for marker scaling character(len=*), intent(in), optional :: markColor Color of markers; overridden by z character(len=*), intent(in), optional :: markStyle Style of markers real(kind=wp), intent(in), optional :: markSize Size of markers Description Create scatter plot of data Calls proc~~scatter~~CallsGraph proc~scatter scatter plschr plschr proc~scatter->plschr plcol1 plcol1 proc~scatter->plcol1 plssym plssym proc~scatter->plssym plptex plptex proc~scatter->plptex interface~mixval mixval proc~scatter->interface~mixval Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~scatter~~CalledByGraph proc~scatter scatter proc~doscatter doScatter proc~doscatter->proc~scatter program~examples_prg examples_prg program~examples_prg->proc~doscatter Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pp), public, dimension(:), allocatable :: xl real(kind=pp), public, dimension(:), allocatable :: yl real(kind=pp), public, dimension(:), allocatable :: cb character(len=32), public :: code integer, public :: k Source Code subroutine scatter ( x , y , c , s , markColor , markStyle , markSize ) !! Create scatter plot of data real ( wp ), dimension (:), intent ( in ) :: x !! x-coordinates of data real ( wp ), dimension (:), intent ( in ) :: y !! y-coordinates of data real ( wp ), dimension (:), intent ( in ), optional :: c !! Data for smooth coloring real ( wp ), dimension (:), intent ( in ), optional :: s !! Data for marker scaling character ( * ), intent ( in ), optional :: markColor !! Color of markers; overridden by z character ( * ), intent ( in ), optional :: markStyle !! Style of markers real ( wp ), intent ( in ), optional :: markSize !! Size of markers real ( pp ), dimension (:), allocatable :: xl , yl real ( pp ), dimension (:), allocatable :: cb character ( 32 ) :: code integer :: k xl = localize ( x ) yl = localize ( y ) if ( present ( markColor )) call setColor ( markColor ) code = getSymbolCode ( '' ) if ( present ( markStyle )) code = getSymbolCode ( markStyle ) if ( present ( markSize )) call plschr ( 0.0_pp , real ( markSize , pp )) if ( present ( markSize )) call plssym ( 0.0_pp , real ( markSize , pp )) if ( present ( c )) cb = real ( mixval ( c ), pp ) do k = 1 , size ( x ) if ( present ( c )) call plcol1 ( real ( ( c ( k ) - cb ( 1 )) / ( cb ( 2 ) - cb ( 1 )) , pp ) ) if ( present ( s )) call plschr ( 0.0_pp , real ( s ( k ), pp )) if ( present ( s )) call plssym ( 0.0_pp , real ( s ( k ), pp )) call plptex ( xl ( k ), yl ( k ), 0.0_pp , 0.0_pp , 0.5_pp , code ) end do call resetPen () end subroutine scatter","tags":"","loc":"proc/scatter.html","title":"scatter – PlPlotLib"},{"text":"public subroutine plot(x, y, lineColor, lineStyle, lineWidth, markColor, markStyle, markSize) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x x-data for plot real(kind=wp), intent(in), dimension(:) :: y y-data for plot character(len=*), intent(in), optional :: lineColor Color of line character(len=*), intent(in), optional :: lineStyle Style of line; '' for no line real(kind=wp), intent(in), optional :: lineWidth Width of line character(len=*), intent(in), optional :: markColor Color of markers, if any character(len=*), intent(in), optional :: markStyle Style of markers; '' or absent for none real(kind=wp), intent(in), optional :: markSize Size of markers, if any Description Plot data using lines and or markers Calls proc~~plot~~CallsGraph proc~plot plot plptex plptex proc~plot->plptex plline plline proc~plot->plline plssym plssym proc~plot->plssym Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~plot~~CalledByGraph proc~plot plot proc~dofillbetween doFillBetween proc~dofillbetween->proc~plot program~basic_prg basic_prg program~basic_prg->proc~plot program~animate_prg animate_prg program~animate_prg->proc~plot proc~dolegend doLegend proc~dolegend->proc~plot proc~makelogo makeLogo proc~makelogo->proc~plot proc~doerror doError proc~doerror->proc~plot proc~doplot doPlot proc~doplot->proc~plot proc~dologplot doLogPlot proc~dologplot->proc~plot program~examples_prg examples_prg program~examples_prg->proc~dofillbetween program~examples_prg->proc~dolegend program~examples_prg->proc~doerror program~examples_prg->proc~doplot program~examples_prg->proc~dologplot program~logo_prg logo_prg program~logo_prg->proc~makelogo Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pp), public, dimension(:), allocatable :: xl real(kind=pp), public, dimension(:), allocatable :: yl character(len=32), public :: code integer, public :: k Source Code subroutine plot ( x , y , lineColor , lineStyle , lineWidth , markColor , markStyle , markSize ) !! Plot data using lines and or markers real ( wp ), dimension (:), intent ( in ) :: x !! x-data for plot real ( wp ), dimension (:), intent ( in ) :: y !! y-data for plot character ( * ), intent ( in ), optional :: lineColor !! Color of line character ( * ), intent ( in ), optional :: lineStyle !! Style of line; '' for no line real ( wp ), intent ( in ), optional :: lineWidth !! Width of line character ( * ), intent ( in ), optional :: markColor !! Color of markers, if any character ( * ), intent ( in ), optional :: markStyle !! Style of markers; '' or absent for none real ( wp ), intent ( in ), optional :: markSize !! Size of markers, if any real ( pp ), dimension (:), allocatable :: xl , yl character ( 32 ) :: code integer :: k xl = localize ( x ) yl = localize ( y ) if ( present ( lineColor )) call setColor ( lineColor ) if ( present ( lineWidth )) call setLineWidth ( lineWidth ) if ( present ( lineStyle )) then call setLineStyle ( lineStyle ) if ( lineStyle /= '' ) call plline ( xl , yl ) else call plline ( xl , yl ) end if call resetPen () if ( present ( markColor )) call setColor ( markColor ) if ( present ( markSize )) call plssym ( 0.0_pp , real ( markSize , pp )) if ( present ( markStyle )) then code = getSymbolCode ( markStyle ) if ( markStyle /= '' ) then do k = 1 , size ( x ) call plptex ( xl ( k ), yl ( k ), 0.0_pp , 0.0_pp , 0.5_pp , code ) end do end if end if call resetPen () end subroutine plot","tags":"","loc":"proc/plot.html","title":"plot – PlPlotLib"},{"text":"public subroutine plot3(x, y, z, lineColor, lineStyle, lineWidth, markColor, markStyle, markSize) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x x-data for plot real(kind=wp), intent(in), dimension(:) :: y y-data for plot real(kind=wp), intent(in), dimension(:) :: z z-data for plot character(len=*), intent(in), optional :: lineColor Color of line character(len=*), intent(in), optional :: lineStyle Style of line; '' for no line real(kind=wp), intent(in), optional :: lineWidth Width of line character(len=*), intent(in), optional :: markColor Color of markers, if any character(len=*), intent(in), optional :: markStyle Style of markers; '' or absent for none real(kind=wp), intent(in), optional :: markSize Size of markers, if any Description Plot data using lines and or markers Calls proc~~plot3~~CallsGraph proc~plot3 plot3 plline3 plline3 proc~plot3->plline3 plptex3 plptex3 proc~plot3->plptex3 plline plline proc~plot3->plline plssym plssym proc~plot3->plssym Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pp), public, dimension(:), allocatable :: xl real(kind=pp), public, dimension(:), allocatable :: yl real(kind=pp), public, dimension(:), allocatable :: zl real(kind=pp), public :: dx real(kind=pp), public :: dy real(kind=pp), public :: dz real(kind=pp), public :: sx real(kind=pp), public :: sy real(kind=pp), public :: sz character(len=32), public :: code integer, public :: k Source Code subroutine plot3 ( x , y , z , lineColor , lineStyle , lineWidth , markColor , markStyle , markSize ) !! Plot data using lines and or markers real ( wp ), dimension (:), intent ( in ) :: x !! x-data for plot real ( wp ), dimension (:), intent ( in ) :: y !! y-data for plot real ( wp ), dimension (:), intent ( in ) :: z !! z-data for plot character ( * ), intent ( in ), optional :: lineColor !! Color of line character ( * ), intent ( in ), optional :: lineStyle !! Style of line; '' for no line real ( wp ), intent ( in ), optional :: lineWidth !! Width of line character ( * ), intent ( in ), optional :: markColor !! Color of markers, if any character ( * ), intent ( in ), optional :: markStyle !! Style of markers; '' or absent for none real ( wp ), intent ( in ), optional :: markSize !! Size of markers, if any real ( pp ), dimension (:), allocatable :: xl , yl , zl real ( pp ) :: dx , dy , dz , sx , sy , sz character ( 32 ) :: code integer :: k xl = localize ( x ) yl = localize ( y ) zl = localize ( z ) if ( present ( lineColor )) call setColor ( lineColor ) if ( present ( lineWidth )) call setLineWidth ( lineWidth ) if ( present ( lineStyle )) then call setLineStyle ( lineStyle ) if ( lineStyle /= '' ) call plline ( xl , yl ) else call plline3 ( xl , yl , zl ) end if call resetPen () if ( present ( markColor )) call setColor ( markColor ) if ( present ( markSize )) call plssym ( 0.0_pp , real ( markSize , pp )) if ( present ( markStyle )) then code = getSymbolCode ( markStyle ) if ( markStyle /= '' ) then dx = 1.0_pp dy = 0.0_pp dz = 0.0_pp sx = 0.0_pp sy = 0.0_pp sz = 0.0_pp do k = 1 , size ( x ) call plptex3 ( xl ( k ), yl ( k ), zl ( k ), dx , dy , dz , sx , sy , sz , 0.5_pp , code ) end do end if end if call resetPen () end subroutine plot3","tags":"","loc":"proc/plot3.html","title":"plot3 – PlPlotLib"},{"text":"public subroutine contour(x, y, z, N, lineColor, lineStyle, lineWidth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x x-coordinates of data real(kind=wp), intent(in), dimension(:) :: y y-coordinates of data real(kind=wp), intent(in), dimension(:,:) :: z Data for contouring integer, intent(in), optional :: N Number of levels to use in contour character(len=*), intent(in), optional :: lineColor Color of contour lines character(len=*), intent(in), optional :: lineStyle Style of contour lines real(kind=wp) , optional :: lineWidth Width of contour lines Description Plot contour lines Calls proc~~contour~~CallsGraph proc~contour contour plcont plcont proc~contour->plcont Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~contour~~CalledByGraph proc~contour contour proc~docontour doContour proc~docontour->proc~contour program~examples_prg examples_prg program~examples_prg->proc~docontour Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pp), public, dimension(:), allocatable :: xl real(kind=pp), public, dimension(:), allocatable :: yl real(kind=pp), public, dimension(:,:), allocatable :: zl real(kind=pp), public, dimension(:), allocatable :: edge integer, public :: Nl integer, public :: k Source Code subroutine contour ( x , y , z , N , lineColor , lineStyle , lineWidth ) !! Plot contour lines real ( wp ), dimension (:), intent ( in ) :: x !! x-coordinates of data real ( wp ), dimension (:), intent ( in ) :: y !! y-coordinates of data real ( wp ), dimension (:,:), intent ( in ) :: z !! Data for contouring integer , intent ( in ), optional :: N !! Number of levels to use in contour character ( * ), intent ( in ), optional :: lineColor !! Color of contour lines character ( * ), intent ( in ), optional :: lineStyle !! Style of contour lines real ( wp ), optional :: lineWidth !! Width of contour lines real ( pp ), dimension (:), allocatable :: xl , yl real ( pp ), dimension (:,:), allocatable :: zl real ( pp ), dimension (:), allocatable :: edge integer :: Nl , k xl = localize ( x ) yl = localize ( y ) zl = localize ( z ) Nl = 20 if ( present ( N )) Nl = N edge = [( real ( k - 1 , pp ) / real ( Nl - 1 , pp ) * ( maxval ( zl ) - minval ( zl )) + minval ( zl ) , k = 1 , Nl )] if ( present ( lineColor )) call setColor ( lineColor ) if ( present ( lineStyle )) call setLineStyle ( lineStyle ) if ( present ( lineWidth )) call setLineWidth ( lineWidth ) call plcont ( zl , edge , xl , yl ) call resetPen () end subroutine contour","tags":"","loc":"proc/contour.html","title":"contour – PlPlotLib"},{"text":"public subroutine surface(x, y, z, N, lineStyle) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x x-coordinates of data real(kind=wp), intent(in), dimension(:) :: y y-coordinates of data real(kind=wp), intent(in), dimension(:,:) :: z Data for contouring integer, intent(in), optional :: N Number of levels to use in surface colors character(len=*), intent(in), optional :: lineStyle Style for xy lines ( '-' = on, '' = off ) Description Plot a 3d surface Calls proc~~surface~~CallsGraph proc~surface surface proc~linspace linspace proc~surface->proc~linspace plsurf3d plsurf3d proc~surface->plsurf3d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~surface~~CalledByGraph proc~surface surface proc~dosurface doSurface proc~dosurface->proc~surface program~examples_prg examples_prg program~examples_prg->proc~dosurface Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pp), public, dimension(:), allocatable :: xl real(kind=pp), public, dimension(:), allocatable :: yl real(kind=pp), public, dimension(:,:), allocatable :: zl real(kind=pp), public, dimension(:), allocatable :: edge integer, public :: Nl integer, public :: opt Source Code subroutine surface ( x , y , z , N , lineStyle ) !! Plot a 3d surface real ( wp ), dimension (:), intent ( in ) :: x !! x-coordinates of data real ( wp ), dimension (:), intent ( in ) :: y !! y-coordinates of data real ( wp ), dimension (:,:), intent ( in ) :: z !! Data for contouring integer , intent ( in ), optional :: N !! Number of levels to use in surface colors character ( * ), intent ( in ), optional :: lineStyle !! Style for xy lines ( '-' = on, '' = off ) real ( pp ), dimension (:), allocatable :: xl , yl real ( pp ), dimension (:,:), allocatable :: zl real ( pp ), dimension (:), allocatable :: edge integer :: Nl , opt opt = MAG_COLOR xl = localize ( x ) yl = localize ( y ) zl = localize ( z ) Nl = 20 if ( present ( N )) then Nl = N opt = ior ( opt , SURF_CONT ) end if edge = localize ( linspace ( minval ( z ), maxval ( z ), Nl )) if ( present ( lineStyle )) then select case ( lineStyle ) case ( '' ) opt = opt case ( '-' ) opt = ior ( opt , FACETED ) end select end if call plsurf3d ( xl , yl , zl , opt , edge ) call resetPen () end subroutine surface","tags":"","loc":"proc/surface.html","title":"surface – PlPlotLib"},{"text":"public subroutine wireframe(x, y, z, lineColor) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x x-coordinates of data real(kind=wp), intent(in), dimension(:) :: y y-coordinates of data real(kind=wp), intent(in), dimension(:,:) :: z Data for contouring character(len=*), intent(in), optional :: lineColor Color of contour lines Description Plot a 3d wireframe Calls proc~~wireframe~~CallsGraph proc~wireframe wireframe plot3d plot3d proc~wireframe->plot3d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pp), public, dimension(:), allocatable :: xl real(kind=pp), public, dimension(:), allocatable :: yl real(kind=pp), public, dimension(:,:), allocatable :: zl Source Code subroutine wireframe ( x , y , z , lineColor ) !! Plot a 3d wireframe real ( wp ), dimension (:), intent ( in ) :: x !! x-coordinates of data real ( wp ), dimension (:), intent ( in ) :: y !! y-coordinates of data real ( wp ), dimension (:,:), intent ( in ) :: z !! Data for contouring character ( * ), intent ( in ), optional :: lineColor !! Color of contour lines real ( pp ), dimension (:), allocatable :: xl , yl real ( pp ), dimension (:,:), allocatable :: zl xl = localize ( x ) yl = localize ( y ) zl = localize ( z ) if ( present ( lineColor )) then call setColor ( lineColor ) call plot3d ( xl , yl , zl , DRAW_LINEXY ,. false .) else call plot3d ( xl , yl , zl , ior ( DRAW_LINEXY , MAG_COLOR ),. false .) end if call resetPen () end subroutine wireframe","tags":"","loc":"proc/wireframe.html","title":"wireframe – PlPlotLib"},{"text":"public subroutine contourf(x, y, z, N) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x x-coordinates of data real(kind=wp), intent(in), dimension(:) :: y y-coordinates of data real(kind=wp), intent(in), dimension(:,:) :: z Data for contouring integer, intent(in), optional :: N Number of levels to use in contour Description Plot filled contours Calls proc~~contourf~~CallsGraph proc~contourf contourf proc~linspace linspace proc~contourf->proc~linspace plshades plshades proc~contourf->plshades Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~contourf~~CalledByGraph proc~contourf contourf proc~docontour doContour proc~docontour->proc~contourf program~examples_prg examples_prg program~examples_prg->proc~docontour Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pp), public, dimension(:), allocatable :: xl real(kind=pp), public, dimension(:), allocatable :: yl real(kind=pp), public, dimension(:,:), allocatable :: zl real(kind=pp), public, dimension(:), allocatable :: edge character(len=1), public :: defined real(kind=pp), public :: fill_width real(kind=pp), public :: cont_width integer, public :: cont_color integer, public :: Nl Source Code subroutine contourf ( x , y , z , N ) !! Plot filled contours real ( wp ), dimension (:), intent ( in ) :: x !! x-coordinates of data real ( wp ), dimension (:), intent ( in ) :: y !! y-coordinates of data real ( wp ), dimension (:,:), intent ( in ) :: z !! Data for contouring integer , intent ( in ), optional :: N !! Number of levels to use in contour real ( pp ), dimension (:), allocatable :: xl , yl real ( pp ), dimension (:,:), allocatable :: zl real ( pp ), dimension (:), allocatable :: edge character ( 1 ) :: defined real ( pp ) :: fill_width real ( pp ) :: cont_width integer :: cont_color integer :: Nl xl = localize ( x ) yl = localize ( y ) zl = localize ( z ) Nl = 20 if ( present ( N )) Nl = N edge = localize ( linspace ( minval ( z ), maxval ( z ), Nl )) fill_width = - 1.0_pp cont_width = - 1.0_pp cont_color = - 1 call plshades ( zl , defined , minval ( xl ), maxval ( xl ), minval ( yl ), maxval ( yl ), & & edge , fill_width , cont_color , cont_width ) call resetPen () end subroutine contourf","tags":"","loc":"proc/contourf.html","title":"contourf – PlPlotLib"},{"text":"public subroutine quiver(x, y, u, v, s, c, scaling, lineColor, lineStyle, lineWidth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x x-positions of vectors real(kind=wp), intent(in), dimension(:) :: y y-positions of vectors real(kind=wp), intent(in), dimension(:,:) :: u u-components of vectors real(kind=wp), intent(in), dimension(:,:) :: v v-components of vectors real(kind=wp), intent(in), optional dimension(:,:) :: s Scale of vectors real(kind=wp), intent(in), optional dimension(:,:) :: c Color values for vectors real(kind=wp), intent(in), optional :: scaling Scaling of vectors\n < 0 = Automatic, then scaled\n   0 = Automatic 0 = Directly scaled character(len=*), intent(in), optional :: lineColor Color of vectors character(len=*), intent(in), optional :: lineStyle Style of vectors' lines real(kind=wp) , optional :: lineWidth Width of vectors' lines Description Plot vectors Calls proc~~quiver~~CallsGraph proc~quiver quiver plvect plvect proc~quiver->plvect interface~mixval mixval proc~quiver->interface~mixval plcol1 plcol1 proc~quiver->plcol1 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~quiver~~CalledByGraph proc~quiver quiver proc~doquiver doQuiver proc~doquiver->proc~quiver program~examples_prg examples_prg program~examples_prg->proc~doquiver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pp), public, dimension(:), allocatable :: xl real(kind=pp), public, dimension(:), allocatable :: yl real(kind=pp), public, dimension(:,:), allocatable :: ul real(kind=pp), public, dimension(:,:), allocatable :: vl real(kind=pp), public, dimension(:,:), allocatable :: sl real(kind=pp), public, dimension(2) :: xb real(kind=pp), public, dimension(2) :: yb real(kind=pp), public, dimension(2) :: sb real(kind=pp), public, dimension(2) :: cb real(kind=pp), public, dimension(2) :: d real(kind=pp), public :: scalingl real(kind=pp), public :: scl real(kind=pp), public :: mag real(kind=pp), public :: clr integer, public :: i integer, public :: j Source Code subroutine quiver ( x , y , u , v , s , c , scaling , lineColor , lineStyle , lineWidth ) !! Plot vectors real ( wp ), dimension (:), intent ( in ) :: x !! x-positions of vectors real ( wp ), dimension (:), intent ( in ) :: y !! y-positions of vectors real ( wp ), dimension (:,:), intent ( in ) :: u !! u-components of vectors real ( wp ), dimension (:,:), intent ( in ) :: v !! v-components of vectors real ( wp ), dimension (:,:), intent ( in ), optional :: s !! Scale of vectors real ( wp ), dimension (:,:), intent ( in ), optional :: c !! Color values for vectors real ( wp ), intent ( in ), optional :: scaling !! Scaling of vectors !! < 0 = Automatic, then scaled !!   0 = Automatic !! > 0 = Directly scaled character ( * ), intent ( in ), optional :: lineColor !! Color of vectors character ( * ), intent ( in ), optional :: lineStyle !! Style of vectors' lines real ( wp ), optional :: lineWidth !! Width of vectors' lines real ( pp ), dimension (:), allocatable :: xl , yl real ( pp ), dimension (:,:), allocatable :: ul , vl , sl real ( pp ), dimension ( 2 ) :: xb , yb , sb , cb , d real ( pp ) :: scalingl , scl , mag , clr integer :: i , j xl = localize ( x ) yl = localize ( y ) ul = localize ( u ) vl = localize ( v ) d = real ([ x ( 2 ) - x ( 1 ), y ( 2 ) - y ( 1 )], pp ) xb = real ( mixval ( x ), pp ) yb = real ( mixval ( y ), pp ) if ( present ( s )) then sl = localize ( s ) sl = sl / maxval ( sl ) else sl = localize ( u ** 2 + v ** 2 ) sl = sqrt ( sl ) sl = sl / maxval ( sl ) end if sb = [ minval ( sl ), maxval ( sl )] cb = 0.0_wp if ( present ( c )) cb = real ([ minval ( c ), maxval ( c )], pp ) scalingl = 1.0_pp if ( present ( scaling )) scalingl = real ( scaling , pp ) if ( present ( lineColor )) call setColor ( lineColor ) if ( present ( lineStyle )) call setLineStyle ( lineStyle ) if ( present ( lineWidth )) call setLineWidth ( lineWidth ) do i = 1 , size ( u , 1 ) do j = 1 , size ( u , 2 ) mag = norm2 ([ ul ( i , j ), vl ( i , j )]) scl = scalingl * norm2 ( d ) * sl ( i , j ) if ( abs ( scl ) < 1.0E-5_wp ) cycle if ( present ( c )) then clr = real ( ( c ( i , j ) - cb ( 1 )) / ( cb ( 2 ) - cb ( 1 )) , pp ) clr = max ( clr , 0.0_pp ) clr = min ( clr , 1.0_pp ) call plcol1 ( clr ) end if call plvect ( ul ( i : i , j : j ) / mag , vl ( i : i , j : j ) / mag , scl , xl ( i : i ), yl ( j : j )) end do end do call resetPen () end subroutine quiver","tags":"","loc":"proc/quiver.html","title":"quiver – PlPlotLib"},{"text":"public subroutine bar(x, y, c, relWidth, fillColor, fillPattern, lineColor, lineWidth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x x-positions of the bars' centers real(kind=wp), intent(in), dimension(:) :: y y-positions of the bars' tops real(kind=wp), intent(in), optional dimension(:) :: c Color scale for bars real(kind=wp), intent(in), optional :: relWidth Relative width of bars (default 0.8) character(len=*), intent(in), optional :: fillColor Color of bar fills character(len=*), intent(in), optional :: fillPattern Pattern of bar fills character(len=*), intent(in), optional :: lineColor Color of lines around bars real(kind=wp) , optional :: lineWidth Width of lines around bars Description Create a bar graph Calls proc~~bar~~CallsGraph proc~bar bar interface~mixval mixval proc~bar->interface~mixval plline plline proc~bar->plline plfill plfill proc~bar->plfill plcol1 plcol1 proc~bar->plcol1 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bar~~CalledByGraph proc~bar bar proc~dohist doHist proc~dohist->proc~bar proc~hist hist proc~dohist->proc~hist proc~hist->proc~bar proc~dobar doBar proc~dobar->proc~bar program~examples_prg examples_prg program~examples_prg->proc~dohist program~examples_prg->proc~dobar Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pp), public, dimension(4) :: xl real(kind=pp), public, dimension(4) :: yl real(kind=pp), public, dimension(2) :: cb real(kind=pp), public :: dx real(kind=pp), public :: dxs integer, public :: k Source Code subroutine bar ( x , y , c , relWidth , fillColor , fillPattern , lineColor , lineWidth ) !! Create a bar graph real ( wp ), dimension (:), intent ( in ) :: x !! x-positions of the bars' centers real ( wp ), dimension (:), intent ( in ) :: y !! y-positions of the bars' tops real ( wp ), dimension (:), intent ( in ), optional :: c !! Color scale for bars real ( wp ), intent ( in ), optional :: relWidth !! Relative width of bars (default 0.8) character ( * ), intent ( in ), optional :: fillColor !! Color of bar fills character ( * ), intent ( in ), optional :: fillPattern !! Pattern of bar fills character ( * ), intent ( in ), optional :: lineColor !! Color of lines around bars real ( wp ), optional :: lineWidth !! Width of lines around bars real ( pp ), dimension ( 4 ) :: xl , yl real ( pp ), dimension ( 2 ) :: cb real ( pp ) :: dx , dxs integer :: k cb = 0.0_wp if ( present ( c )) cb = real ( mixval ( c ), pp ) dxs = 0.8_pp if ( present ( relWidth )) dxs = real ( relWidth , pp ) if ( size ( x ) > 1 ) then dx = dxs * real ( x ( 2 ) - x ( 1 ), pp ) / 2.0_pp else dx = dxs end if if ( present ( lineWidth )) call setLineWidth ( lineWidth ) do k = 1 , size ( x ) xl = real ([ x ( k ) - dx , x ( k ) - dx , x ( k ) + dx , x ( k ) + dx ], pp ) yl = real ([ 0.0_wp , y ( k ), y ( k ), 0.0_wp ], pp ) if ( present ( fillColor )) call setColor ( fillColor ) if ( present ( fillPattern )) call setFillPattern ( fillPattern ) if ( present ( c )) call plcol1 ( real ( ( c ( k ) - cb ( 1 )) / ( cb ( 2 ) - cb ( 1 )) , pp ) ) call plfill ( xl , yl ) if ( present ( lineColor )) call setColor ( lineColor ) call plline ( xl , yl ) end do call resetPen () end subroutine bar","tags":"","loc":"proc/bar.html","title":"bar – PlPlotLib"},{"text":"public subroutine barh(y, x, c, relWidth, fillColor, fillPattern, lineColor, lineWidth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: y y-positions of the bars' centers real(kind=wp), intent(in), dimension(:) :: x x-positions of the bars' tops real(kind=wp), intent(in), optional dimension(:) :: c Color scale for bars real(kind=wp), intent(in), optional :: relWidth Relative width of bars character(len=*), intent(in), optional :: fillColor Color of bar fills character(len=*), intent(in), optional :: fillPattern Pattern of bar fills character(len=*), intent(in), optional :: lineColor Color of lines around bars real(kind=wp) , optional :: lineWidth Width of lines around bars Description Create a horizontal bar graph Calls proc~~barh~~CallsGraph proc~barh barh interface~mixval mixval proc~barh->interface~mixval plline plline proc~barh->plline plfill plfill proc~barh->plfill plcol1 plcol1 proc~barh->plcol1 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~barh~~CalledByGraph proc~barh barh proc~dobar doBar proc~dobar->proc~barh program~examples_prg examples_prg program~examples_prg->proc~dobar Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pp), public, dimension(4) :: xl real(kind=pp), public, dimension(4) :: yl real(kind=pp), public, dimension(2) :: cb real(kind=pp), public :: dy real(kind=pp), public :: dys integer, public :: k Source Code subroutine barh ( y , x , c , relWidth , fillColor , fillPattern , lineColor , lineWidth ) !! Create a horizontal bar graph real ( wp ), dimension (:), intent ( in ) :: y !! y-positions of the bars' centers real ( wp ), dimension (:), intent ( in ) :: x !! x-positions of the bars' tops real ( wp ), dimension (:), intent ( in ), optional :: c !! Color scale for bars real ( wp ), intent ( in ), optional :: relWidth !! Relative width of bars character ( * ), intent ( in ), optional :: fillColor !! Color of bar fills character ( * ), intent ( in ), optional :: fillPattern !! Pattern of bar fills character ( * ), intent ( in ), optional :: lineColor !! Color of lines around bars real ( wp ), optional :: lineWidth !! Width of lines around bars real ( pp ), dimension ( 4 ) :: xl , yl real ( pp ), dimension ( 2 ) :: cb real ( pp ) :: dy , dys integer :: k cb = 0.0_wp if ( present ( c )) cb = real ( mixval ( c ), pp ) dys = 0.8_pp if ( present ( relWidth )) dys = real ( relWidth , pp ) dy = dys * real ( y ( 2 ) - y ( 1 ), pp ) / 2.0_pp if ( present ( lineWidth )) call setLineWidth ( lineWidth ) do k = 1 , size ( x ) yl = real ([ y ( k ) - dy , y ( k ) - dy , y ( k ) + dy , y ( k ) + dy ], pp ) xl = real ([ 0.0_wp , x ( k ), x ( k ), 0.0_wp ], pp ) if ( present ( fillColor )) call setColor ( fillColor ) if ( present ( fillPattern )) call setFillPattern ( fillPattern ) if ( present ( c )) call plcol1 ( real ( ( c ( k ) - cb ( 1 )) / ( cb ( 2 ) - cb ( 1 )) , pp ) ) call plfill ( xl , yl ) if ( present ( lineColor )) call setColor ( lineColor ) call plline ( xl , yl ) end do call resetPen () end subroutine barh","tags":"","loc":"proc/barh.html","title":"barh – PlPlotLib"},{"text":"public subroutine fillBetween(x, y1, y0, fillColor, fillPattern, lineWidth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y1 real(kind=wp), intent(in), optional dimension(:) :: y0 character(len=*), intent(in), optional :: fillColor character(len=*), intent(in), optional :: fillPattern real(kind=wp), intent(in), optional :: lineWidth Description Fill space between two lines Calls proc~~fillbetween~~CallsGraph proc~fillbetween fillBetween plfill plfill proc~fillbetween->plfill Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~fillbetween~~CalledByGraph proc~fillbetween fillBetween proc~dofillbetween doFillBetween proc~dofillbetween->proc~fillbetween program~examples_prg examples_prg program~examples_prg->proc~dofillbetween Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pp), public, dimension(:), allocatable :: xl real(kind=pp), public, dimension(:), allocatable :: y1l real(kind=pp), public, dimension(:), allocatable :: y0l integer, public :: N Source Code subroutine fillBetween ( x , y1 , y0 , fillColor , fillPattern , lineWidth ) !! Fill space between two lines real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y1 real ( wp ), dimension (:), intent ( in ), optional :: y0 character ( * ), intent ( in ), optional :: fillColor character ( * ), intent ( in ), optional :: fillPattern real ( wp ), intent ( in ), optional :: lineWidth real ( pp ), dimension (:), allocatable :: xl , y1l , y0l integer :: N N = size ( x ) xl = localize ( x ) y1l = localize ( y1 ) if ( present ( y0 )) then y0l = localize ( y0 ) else allocate ( y0l ( N )) y0l = 0.0_pp end if if ( present ( fillColor )) call setColor ( fillColor ) if ( present ( fillPattern )) call setFillPattern ( fillPattern ) if ( present ( lineWidth )) call setLineWidth ( lineWidth ) call plfill ([ xl ( 1 : N : 1 ), xl ( N : 1 : - 1 )],[ y1l ( 1 : N : 1 ), y0l ( N : 1 : - 1 )]) call resetPen () end subroutine fillBetween","tags":"","loc":"proc/fillbetween.html","title":"fillBetween – PlPlotLib"},{"text":"public subroutine fillBetweenx(y, x1, x0, fillColor, fillPattern, lineWidth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: x1 real(kind=wp), intent(in), optional dimension(:) :: x0 character(len=*), intent(in), optional :: fillColor character(len=*), intent(in), optional :: fillPattern real(kind=wp), intent(in), optional :: lineWidth Description Fill space between two lines Calls proc~~fillbetweenx~~CallsGraph proc~fillbetweenx fillBetweenx plfill plfill proc~fillbetweenx->plfill Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pp), public, dimension(:), allocatable :: yl real(kind=pp), public, dimension(:), allocatable :: x1l real(kind=pp), public, dimension(:), allocatable :: x0l integer, public :: N Source Code subroutine fillBetweenx ( y , x1 , x0 , fillColor , fillPattern , lineWidth ) !! Fill space between two lines real ( wp ), dimension (:), intent ( in ) :: y real ( wp ), dimension (:), intent ( in ) :: x1 real ( wp ), dimension (:), intent ( in ), optional :: x0 character ( * ), intent ( in ), optional :: fillColor character ( * ), intent ( in ), optional :: fillPattern real ( wp ), intent ( in ), optional :: lineWidth real ( pp ), dimension (:), allocatable :: yl , x1l , x0l integer :: N N = size ( y ) yl = localize ( y ) x1l = localize ( x1 ) if ( present ( x0 )) then x0l = localize ( x0 ) else allocate ( x0l ( N )) x0l = 0.0_pp end if if ( present ( fillColor )) call setColor ( fillColor ) if ( present ( fillPattern )) call setFillPattern ( fillPattern ) if ( present ( lineWidth )) call setLineWidth ( lineWidth ) call plfill ([ x1l ( 1 : N : 1 ), x0l ( N : 1 : - 1 )],[ yl ( 1 : N : 1 ), yl ( N : 1 : - 1 )]) call resetPen () end subroutine fillBetweenx","tags":"","loc":"proc/fillbetweenx.html","title":"fillBetweenx – PlPlotLib"},{"text":"public subroutine errorbar(x, y, xerr, yerr, lineColor, lineStyle, lineWidth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x x-data for plot real(kind=wp), intent(in), dimension(:) :: y y-data for plot real(kind=wp), intent(in), optional dimension(:) :: xerr x-data error for plot real(kind=wp), intent(in), optional dimension(:) :: yerr y-data error for plot character(len=*), intent(in), optional :: lineColor Color of line character(len=*), intent(in), optional :: lineStyle Style of line; '' for no line real(kind=wp), intent(in), optional :: lineWidth Width of line Description Plot error bars for a set of data points Calls proc~~errorbar~~CallsGraph proc~errorbar errorbar plerrx plerrx proc~errorbar->plerrx plerry plerry proc~errorbar->plerry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~errorbar~~CalledByGraph proc~errorbar errorbar proc~doerror doError proc~doerror->proc~errorbar program~examples_prg examples_prg program~examples_prg->proc~doerror Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pp), public, dimension(:), allocatable :: xl real(kind=pp), public, dimension(:), allocatable :: yl real(kind=pp), public, dimension(:), allocatable :: xll real(kind=pp), public, dimension(:), allocatable :: xlh real(kind=pp), public, dimension(:), allocatable :: yll real(kind=pp), public, dimension(:), allocatable :: ylh","tags":"","loc":"proc/errorbar.html","title":"errorbar – PlPlotLib"},{"text":"public subroutine setup(device, fileName, fontScaling, whiteOnBlack, transparent, colormap, figSize) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: device Output device to use qtwidget svgqt pngqt character(len=*), intent(in), optional :: fileName Name of file(s) to write to The text %n will be replaced with the figure number real(kind=wp), intent(in), optional :: fontScaling Font scaling relative to default value logical, intent(in), optional :: whiteOnBlack Default foreground and background colors logical, intent(in), optional :: transparent Transparent background character(len=*), intent(in), optional :: colormap Colormap to use integer, intent(in), optional dimension(2) :: figSize Size of figures to produce in pixels Description Setup PlPlot library, optionally overriding defaults Calls proc~~setup~~CallsGraph proc~setup setup plinit plinit proc~setup->plinit plsdev plsdev proc~setup->plsdev plsfam plsfam proc~setup->plsfam plsfnam plsfnam proc~setup->plsfnam plfontld plfontld proc~setup->plfontld plsetopt plsetopt proc~setup->plsetopt Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~setup~~CalledByGraph proc~setup setup program~logo_prg logo_prg program~logo_prg->proc~setup program~animate_prg animate_prg program~animate_prg->proc~setup program~basic_prg basic_prg program~basic_prg->proc~setup program~examples_prg examples_prg program~examples_prg->proc~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=64), public :: bufx character(len=64), public :: bufy Source Code subroutine setup ( device , fileName , fontScaling , whiteOnBlack , transparent , colormap , figSize ) !! Setup PlPlot library, optionally overriding defaults character ( * ), intent ( in ), optional :: device !! Output device to use !! !! * qtwidget !! * svgqt !! * pngqt character ( * ), intent ( in ), optional :: fileName !! Name of file(s) to write to !! !! The text `%n` will be replaced with the figure number real ( wp ), intent ( in ), optional :: fontScaling !! Font scaling relative to default value logical , intent ( in ), optional :: whiteOnBlack !! Default foreground and background colors logical , intent ( in ), optional :: transparent !! Transparent background character ( * ), intent ( in ), optional :: colormap !! Colormap to use integer , dimension ( 2 ), intent ( in ), optional :: figSize !! Size of figures to produce in pixels character ( 64 ) :: bufx , bufy if ( present ( device )) then call plsdev ( device ) else call plsdev ( default_dev ) end if call plsfam ( 1 , 1 , 100 ) if ( present ( fileName )) then call plsfnam ( fileName ) else call plsfnam ( 'out' ) end if if ( present ( whiteOnBlack )) blackOnWhite = . not . whiteOnBlack if ( present ( transparent )) transparentBackground = transparent call setIndexedColors () if ( present ( colormap )) then call setColormap ( colormap ) else call setColormap ( 'CoolWarm' ) end if call plfontld ( 0 ) if ( present ( fontScaling )) fontScale = real ( fontScaling , pp ) if ( present ( figSize )) then write ( bufx , * ) figSize ( 1 ) write ( bufy , * ) figSize ( 2 ) call plsetopt ( 'geometry' , trim ( adjustl ( bufx )) // 'x' // trim ( adjustl ( bufy ))) else call plsetopt ( 'geometry' , '640x480' ) end if call plinit () call resetPen () end subroutine setup","tags":"","loc":"proc/setup.html","title":"setup – PlPlotLib"},{"text":"public subroutine show() Arguments None Description Show the plots end finialize the PlPlot library Calls proc~~show~~CallsGraph proc~show show plend plend proc~show->plend Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~show~~CalledByGraph proc~show show program~logo_prg logo_prg program~logo_prg->proc~show program~animate_prg animate_prg program~animate_prg->proc~show program~basic_prg basic_prg program~basic_prg->proc~show program~examples_prg examples_prg program~examples_prg->proc~show Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine show !! Show the plots end finialize the PlPlot library if (. not . didShow ) then call plend () didShow = . true . end if end subroutine show","tags":"","loc":"proc/show.html","title":"show – PlPlotLib"},{"text":"public subroutine printTypes() Arguments None Description Print the integer kinds for each real type Source Code subroutine printTypes !! Print the integer kinds for each real type write ( * , * ) 'sp: ' , sp write ( * , * ) 'dp: ' , dp write ( * , * ) 'ep: ' , ep write ( * , * ) 'qp: ' , qp write ( * , * ) 'wp: ' , wp end subroutine printTypes","tags":"","loc":"proc/printtypes.html","title":"printTypes – PlPlotLib"},{"text":"subroutine makeLogo() Arguments None Calls proc~~makelogo~~CallsGraph proc~makelogo makeLogo proc~linspace linspace proc~makelogo->proc~linspace interface~mixval mixval proc~makelogo->interface~mixval proc~ticks ticks proc~makelogo->proc~ticks proc~plot plot proc~makelogo->proc~plot proc~xylim xylim proc~makelogo->proc~xylim proc~subplot subplot proc~makelogo->proc~subplot proc~figure figure proc~makelogo->proc~figure proc~labels labels proc~makelogo->proc~labels plbox plbox proc~ticks->plbox plptex plptex proc~plot->plptex plline plline proc~plot->plline plssym plssym proc~plot->plssym plwind plwind proc~xylim->plwind plvsta plvsta proc~subplot->plvsta plssub plssub proc~subplot->plssub plvasp plvasp proc~subplot->plvasp plvpor plvpor proc~subplot->plvpor pladv pladv proc~subplot->pladv proc~figure->plssub proc~figure->pladv pleop pleop proc~figure->pleop plbop plbop proc~figure->plbop pllab pllab proc~labels->pllab Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~makelogo~~CalledByGraph proc~makelogo makeLogo program~logo_prg logo_prg program~logo_prg->proc~makelogo Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:), allocatable :: x real(kind=wp), public, dimension(:), allocatable :: y1 real(kind=wp), public, dimension(:), allocatable :: y2 real(kind=wp), public, dimension(:), allocatable :: y3 Source Code subroutine makeLogo real ( wp ), dimension (:), allocatable :: x , y1 , y2 , y3 x = linspace ( 0.0_wp , 1.0_wp , 100 ) y1 = x ** 2 - 1.0_wp y2 = 2.0_wp * x - 1.0_wp y3 = x y3 = cos ( 2.0_wp * PI * x ) call figure () call subplot ( 1 , 1 , 1 ) call xylim ( mixval ( x ), mixval ([ y1 , y2 , y3 ]) * 1.1_wp ) call plot ( x , y1 , lineColor = 'b' , lineWidth = 1 0.0_wp ) call plot ( x , y2 , lineColor = 'r' , lineWidth = 1 0.0_wp ) call plot ( x , y3 , lineColor = 'c' , lineWidth = 1 0.0_wp ) call ticks ( lineWidth = 5.0_wp ) call labels ( '' , '' , '' ) end subroutine makeLogo","tags":"","loc":"proc/makelogo.html","title":"makeLogo – PlPlotLib"},{"text":"subroutine doPlot() Arguments None Description Calls proc~~doplot~~CallsGraph proc~doplot doPlot proc~linspace linspace proc~doplot->proc~linspace proc~ylabel ylabel proc~doplot->proc~ylabel proc~xlabel xlabel proc~doplot->proc~xlabel interface~mixval mixval proc~doplot->interface~mixval proc~plot plot proc~doplot->proc~plot proc~xticks xticks proc~doplot->proc~xticks proc~xylim xylim proc~doplot->proc~xylim proc~subplot subplot proc~doplot->proc~subplot proc~figure figure proc~doplot->proc~figure proc~yticks yticks proc~doplot->proc~yticks proc~title title proc~doplot->proc~title plmtex plmtex proc~ylabel->plmtex proc~xlabel->plmtex plptex plptex proc~plot->plptex plline plline proc~plot->plline plssym plssym proc~plot->plssym plbox plbox proc~xticks->plbox plwind plwind proc~xylim->plwind plvsta plvsta proc~subplot->plvsta plssub plssub proc~subplot->plssub plvasp plvasp proc~subplot->plvasp plvpor plvpor proc~subplot->plvpor pladv pladv proc~subplot->pladv proc~figure->plssub proc~figure->pladv pleop pleop proc~figure->pleop plbop plbop proc~figure->plbop proc~yticks->plbox proc~title->plmtex Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~doplot~~CalledByGraph proc~doplot doPlot program~examples_prg examples_prg program~examples_prg->proc~doplot Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: N = 20 real(kind=wp), public, dimension(N) :: x real(kind=wp), public, dimension(N) :: y Source Code subroutine doPlot !! ![plot](|media|/example-1.svg) integer , parameter :: N = 20 real ( wp ), dimension ( N ) :: x , y x = linspace ( 0.0_wp , 1.0_wp , N ) y = x ** 2 - 1.0_wp call figure () call subplot ( 1 , 1 , 1 ) call xylim ( mixval ( x ), mixval ( y )) call plot ( x , y , lineColor = 'red' , lineWidth = 2.0_wp , & & markStyle = '.' , markColor = 'cyan' , markSize = 2.0_wp ) call plot ( x , - 1.0_wp - y , lineColor = 'blue' , lineStyle = ':' , lineWidth = 2.0_wp , & & markStyle = '+' , markColor = 'green' , markSize = 1.0_wp ) !~ \t\tcall ticks() call xticks ( primary = . true ., secondary = . false .) call yticks ( primary = . true ., secondary = . false .) !~ \t\tcall labels('x','y','f(x)=x#u2#d-1; g(x)=-x#u2#d') call xlabel ( 'x' ) call ylabel ( 'y' ) call title ( 'f(x)=x#u2#d-1; g(x)=-x#u2#d' ) end subroutine doPlot","tags":"","loc":"proc/doplot.html","title":"doPlot – PlPlotLib"},{"text":"subroutine doScatter() Arguments None Description Calls proc~~doscatter~~CallsGraph proc~doscatter doScatter proc~scatter scatter proc~doscatter->proc~scatter proc~figure figure proc~doscatter->proc~figure proc~xylim xylim proc~doscatter->proc~xylim proc~labels labels proc~doscatter->proc~labels proc~ticks ticks proc~doscatter->proc~ticks proc~subplot subplot proc~doscatter->proc~subplot plschr plschr proc~scatter->plschr plcol1 plcol1 proc~scatter->plcol1 plssym plssym proc~scatter->plssym plptex plptex proc~scatter->plptex interface~mixval mixval proc~scatter->interface~mixval pladv pladv proc~figure->pladv plssub plssub proc~figure->plssub pleop pleop proc~figure->pleop plbop plbop proc~figure->plbop plwind plwind proc~xylim->plwind pllab pllab proc~labels->pllab plbox plbox proc~ticks->plbox proc~subplot->pladv proc~subplot->plssub plvsta plvsta proc~subplot->plvsta plvasp plvasp proc~subplot->plvasp plvpor plvpor proc~subplot->plvpor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~doscatter~~CalledByGraph proc~doscatter doScatter program~examples_prg examples_prg program~examples_prg->proc~doscatter Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: N = 100 real(kind=wp), public, dimension(N) :: x real(kind=wp), public, dimension(N) :: y real(kind=wp), public, dimension(N) :: z Source Code subroutine doScatter !! ![scatter](|media|/example-2.svg) integer , parameter :: N = 100 real ( wp ), dimension ( N ) :: x , y , z call random_number ( x ) call random_number ( y ) z = sqrt ( x ** 2 + y ** 2 ) call figure () call subplot ( 2 , 2 , 1 ) call xylim ([ 0.0_wp , 1.0_wp ],[ 0.0_wp , 1.0_wp ]) call scatter ( x , y ) call ticks () call labels ( 'x' , 'y' , '' ) call subplot ( 2 , 2 , 2 ) call xylim ([ 0.0_wp , 1.0_wp ],[ 0.0_wp , 1.0_wp ]) call scatter ( x , y , c = z ) call ticks () call labels ( 'x' , 'y' , '' ) call subplot ( 2 , 2 , 3 ) call xylim ([ 0.0_wp , 1.0_wp ],[ 0.0_wp , 1.0_wp ]) call scatter ( x , y , s = ( 4.0_wp * z + 1.0_wp ), markColor = 'blue' ) call ticks () call labels ( 'x' , 'y' , '' ) call subplot ( 2 , 2 , 4 ) call xylim ([ 0.0_wp , 1.0_wp ],[ 0.0_wp , 1.0_wp ]) call scatter ( x , y , c = z , s = ( 4.0_wp * z + 1.0_wp )) call ticks () call labels ( 'x' , 'y' , '' ) end subroutine doScatter","tags":"","loc":"proc/doscatter.html","title":"doScatter – PlPlotLib"},{"text":"subroutine doContour() Arguments None Description Calls proc~~docontour~~CallsGraph proc~docontour doContour proc~linspace linspace proc~docontour->proc~linspace proc~contour contour proc~docontour->proc~contour interface~mixval mixval proc~docontour->interface~mixval proc~ticks ticks proc~docontour->proc~ticks proc~xylim xylim proc~docontour->proc~xylim proc~labels labels proc~docontour->proc~labels proc~subplot subplot proc~docontour->proc~subplot proc~figure figure proc~docontour->proc~figure proc~contourf contourf proc~docontour->proc~contourf proc~colorbar colorbar proc~docontour->proc~colorbar plcont plcont proc~contour->plcont plbox plbox proc~ticks->plbox plwind plwind proc~xylim->plwind pllab pllab proc~labels->pllab plvsta plvsta proc~subplot->plvsta plssub plssub proc~subplot->plssub plvasp plvasp proc~subplot->plvasp plvpor plvpor proc~subplot->plvpor pladv pladv proc~subplot->pladv proc~figure->plssub proc~figure->pladv pleop pleop proc~figure->pleop plbop plbop proc~figure->plbop proc~contourf->proc~linspace plshades plshades proc~contourf->plshades plcolorbar plcolorbar proc~colorbar->plcolorbar Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~docontour~~CalledByGraph proc~docontour doContour program~examples_prg examples_prg program~examples_prg->proc~docontour Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: N = 50 real(kind=wp), public, dimension(N) :: x real(kind=wp), public, dimension(N) :: y real(kind=wp), public, dimension(N,N) :: z integer, public :: i integer, public :: j Source Code subroutine doContour !! ![contour](|media|/example-3.svg) integer , parameter :: N = 50 real ( wp ), dimension ( N ) :: x , y real ( wp ), dimension ( N , N ) :: z integer :: i , j x = linspace ( - 1 0.0_wp , 1 0.0_wp , N ) y = linspace ( - 1 0.0_wp , 1 0.0_wp , N ) forall ( i = 1 : N , j = 1 : N ) z ( i , j ) = sin ( sqrt ( x ( i ) ** 2 + y ( j ) ** 2 ) ) / sqrt ( x ( i ) ** 2 + y ( j ) ** 2 ) end forall call figure () call subplot ( 1 , 1 , 1 , aspect = 1.0_wp ) call xylim ( mixval ( x ), mixval ( y )) call contourf ( x , y , z , 10 ) call contour ( x , y , z , 10 ) call colorbar ( z , 5 ) call ticks () call labels ( 'x' , 'y' , '' ) end subroutine doContour","tags":"","loc":"proc/docontour.html","title":"doContour – PlPlotLib"},{"text":"subroutine doLegend() Arguments None Description Calls proc~~dolegend~~CallsGraph proc~dolegend doLegend proc~linspace linspace proc~dolegend->proc~linspace interface~mixval mixval proc~dolegend->interface~mixval proc~ticks ticks proc~dolegend->proc~ticks proc~plot plot proc~dolegend->proc~plot proc~xylim xylim proc~dolegend->proc~xylim proc~subplot subplot proc~dolegend->proc~subplot proc~figure figure proc~dolegend->proc~figure proc~legend legend proc~dolegend->proc~legend proc~labels labels proc~dolegend->proc~labels plbox plbox proc~ticks->plbox plptex plptex proc~plot->plptex plline plline proc~plot->plline plssym plssym proc~plot->plssym plwind plwind proc~xylim->plwind plvsta plvsta proc~subplot->plvsta plssub plssub proc~subplot->plssub plvasp plvasp proc~subplot->plvasp plvpor plvpor proc~subplot->plvpor pladv pladv proc~subplot->pladv proc~figure->plssub proc~figure->pladv pleop pleop proc~figure->pleop plbop plbop proc~figure->plbop none~doboxes doBoxes proc~legend->none~doboxes none~dolines doLines proc~legend->none~dolines none~dolegendbox doLegendBox proc~legend->none~dolegendbox none~domarkers doMarkers proc~legend->none~domarkers pllegend pllegend proc~legend->pllegend none~dotext doText proc~legend->none~dotext pllab pllab proc~labels->pllab series series none~doboxes->series none~dolines->series none~getcorner getCorner none~dolegendbox->none~getcorner none~domarkers->series none~dotext->series proc~startswith startsWith none~getcorner->proc~startswith proc~endswith endsWith none~getcorner->proc~endswith Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~dolegend~~CalledByGraph proc~dolegend doLegend program~examples_prg examples_prg program~examples_prg->proc~dolegend Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: N = 20 real(kind=wp), public, dimension(N) :: x real(kind=wp), public, dimension(N) :: y character(len=32), public, dimension(3,7) :: series Source Code subroutine doLegend !! ![legend](|media|/example-4.svg) integer , parameter :: N = 20 real ( wp ), dimension ( N ) :: x , y character ( 32 ), dimension ( 3 , 7 ) :: series x = linspace ( 0.0_wp , 1.0_wp , N ) y = x ** 2 - 1.0_wp call figure () call subplot ( 1 , 1 , 1 ) call xylim ( mixval ( x ), mixval ( y )) call plot ( x , y , lineColor = 'red' , lineWidth = 2.0_wp , & & markStyle = '.' , markColor = 'cyan' , markSize = 2.0_wp ) call plot ( x , - 1.0_wp - y , lineColor = 'blue' , lineStyle = ':' , lineWidth = 2.0_wp , & & markStyle = '+' , markColor = 'green' , markSize = 1.0_wp ) ! [name,textColor,lineStyle,lineColor,markStyle,markColor] series ( 1 ,:) = [ character ( 32 ) :: 'f(x)=x#u2#d-1' , '' , '-' , 'r' , '.' , 'c' , '' ] series ( 2 ,:) = [ character ( 32 ) :: 'g(x)=-x#u2#d' , '' , ':' , 'b' , '+' , 'g' , '' ] series ( 3 ,:) = [ character ( 32 ) :: 'Box' , '' , '' , '' , '' , '' , 'r' ] call legend ( 'center left' , series ) call ticks () call labels ( 'x' , 'y' , '' ) end subroutine doLegend","tags":"","loc":"proc/dolegend.html","title":"doLegend – PlPlotLib"},{"text":"subroutine doQuiver() Arguments None Description Calls proc~~doquiver~~CallsGraph proc~doquiver doQuiver proc~linspace linspace proc~doquiver->proc~linspace proc~colorbar colorbar proc~doquiver->proc~colorbar interface~mixval mixval proc~doquiver->interface~mixval proc~ticks ticks proc~doquiver->proc~ticks proc~xylim xylim proc~doquiver->proc~xylim proc~labels labels proc~doquiver->proc~labels proc~quiver quiver proc~doquiver->proc~quiver proc~figure figure proc~doquiver->proc~figure proc~subplot subplot proc~doquiver->proc~subplot plcolorbar plcolorbar proc~colorbar->plcolorbar plbox plbox proc~ticks->plbox plwind plwind proc~xylim->plwind pllab pllab proc~labels->pllab proc~quiver->interface~mixval plvect plvect proc~quiver->plvect plcol1 plcol1 proc~quiver->plcol1 pladv pladv proc~figure->pladv plssub plssub proc~figure->plssub pleop pleop proc~figure->pleop plbop plbop proc~figure->plbop proc~subplot->pladv proc~subplot->plssub plvsta plvsta proc~subplot->plvsta plvasp plvasp proc~subplot->plvasp plvpor plvpor proc~subplot->plvpor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~doquiver~~CalledByGraph proc~doquiver doQuiver program~examples_prg examples_prg program~examples_prg->proc~doquiver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: N = 20 real(kind=wp), public, dimension(N) :: x real(kind=wp), public, dimension(N) :: y real(kind=wp), public, dimension(N,N) :: u real(kind=wp), public, dimension(N,N) :: v real(kind=wp), public, dimension(N,N) :: m integer, public :: i integer, public :: j Source Code subroutine doQuiver !! ![quiver](|media|/example-5.svg) integer , parameter :: N = 20 real ( wp ), dimension ( N ) :: x , y real ( wp ), dimension ( N , N ) :: u , v , m integer :: i , j x = linspace ( - 1 0.0_wp , 1 0.0_wp , N ) y = linspace ( - 1 0.0_wp , 1 0.0_wp , N ) forall ( i = 1 : N , j = 1 : N ) u ( i , j ) = - y ( j ) v ( i , j ) = x ( i ) m ( i , j ) = sqrt ( u ( i , j ) ** 2 + v ( i , j ) ** 2 ) end forall call figure () call subplot ( 1 , 1 , 1 , aspect = 1.0_wp ) call xylim ( mixval ( x ), mixval ( y )) call quiver ( x , y , u , v , c = m , s = m , scaling = 2.0_wp , lineWidth = 2.0_wp ) call colorbar ( m , 10 ) call ticks () call labels ( 'x' , 'y' , '' ) end subroutine doQuiver","tags":"","loc":"proc/doquiver.html","title":"doQuiver – PlPlotLib"},{"text":"subroutine doBar() Arguments None Description Calls proc~~dobar~~CallsGraph proc~dobar doBar proc~linspace linspace proc~dobar->proc~linspace interface~mixval mixval proc~dobar->interface~mixval proc~ticks ticks proc~dobar->proc~ticks proc~xylim xylim proc~dobar->proc~xylim proc~subplot subplot proc~dobar->proc~subplot proc~figure figure proc~dobar->proc~figure proc~barh barh proc~dobar->proc~barh proc~bar bar proc~dobar->proc~bar proc~labels labels proc~dobar->proc~labels plbox plbox proc~ticks->plbox plwind plwind proc~xylim->plwind plvsta plvsta proc~subplot->plvsta plssub plssub proc~subplot->plssub plvasp plvasp proc~subplot->plvasp plvpor plvpor proc~subplot->plvpor pladv pladv proc~subplot->pladv proc~figure->plssub proc~figure->pladv pleop pleop proc~figure->pleop plbop plbop proc~figure->plbop proc~barh->interface~mixval plline plline proc~barh->plline plfill plfill proc~barh->plfill plcol1 plcol1 proc~barh->plcol1 proc~bar->interface~mixval proc~bar->plline proc~bar->plfill proc~bar->plcol1 pllab pllab proc~labels->pllab Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~dobar~~CalledByGraph proc~dobar doBar program~examples_prg examples_prg program~examples_prg->proc~dobar Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: N = 21 real(kind=wp), public, dimension(N) :: x real(kind=wp), public, dimension(N) :: y Source Code subroutine doBar !! ![bar](|media|/example-6.svg) integer , parameter :: N = 21 real ( wp ), dimension ( N ) :: x , y x = linspace ( - PI , PI , N ) y = exp ( - x ** 2 ) call figure () call subplot ( 1 , 2 , 1 ) call xylim ( mixval ( x ) + [ - 0.1_wp , 0.1_wp ], mixval ( y ) + [ 0.0_wp , 0.1_wp ]) call bar ( x , y , c = y , relWidth = 1.0_wp ) call ticks () call labels ( 'x' , 'y' , '' ) call subplot ( 1 , 2 , 2 ) call xylim ( mixval ( y ) + [ 0.0_wp , 0.1_wp ], mixval ( x ) + [ - 0.1_wp , 0.1_wp ]) call barh ( x , y , fillColor = 'r' , relWidth = 1.0_wp ) call ticks () call labels ( 'x' , 'y' , '' ) end subroutine doBar","tags":"","loc":"proc/dobar.html","title":"doBar – PlPlotLib"},{"text":"subroutine doFillBetween() Arguments None Description Calls proc~~dofillbetween~~CallsGraph proc~dofillbetween doFillBetween proc~linspace linspace proc~dofillbetween->proc~linspace interface~mixval mixval proc~dofillbetween->interface~mixval proc~ticks ticks proc~dofillbetween->proc~ticks proc~fillbetween fillBetween proc~dofillbetween->proc~fillbetween proc~plot plot proc~dofillbetween->proc~plot proc~xylim xylim proc~dofillbetween->proc~xylim proc~subplot subplot proc~dofillbetween->proc~subplot proc~figure figure proc~dofillbetween->proc~figure proc~labels labels proc~dofillbetween->proc~labels plbox plbox proc~ticks->plbox plfill plfill proc~fillbetween->plfill plptex plptex proc~plot->plptex plline plline proc~plot->plline plssym plssym proc~plot->plssym plwind plwind proc~xylim->plwind plvsta plvsta proc~subplot->plvsta plssub plssub proc~subplot->plssub plvasp plvasp proc~subplot->plvasp plvpor plvpor proc~subplot->plvpor pladv pladv proc~subplot->pladv proc~figure->plssub proc~figure->pladv pleop pleop proc~figure->pleop plbop plbop proc~figure->plbop pllab pllab proc~labels->pllab Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~dofillbetween~~CalledByGraph proc~dofillbetween doFillBetween program~examples_prg examples_prg program~examples_prg->proc~dofillbetween Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: N = 51 real(kind=wp), public, dimension(N) :: x real(kind=wp), public, dimension(N) :: y1 real(kind=wp), public, dimension(N) :: y2 Source Code subroutine doFillBetween !! ![fillBetween](|media|/example-7.svg) integer , parameter :: N = 51 real ( wp ), dimension ( N ) :: x , y1 , y2 x = linspace ( - 3.0_wp , 3.0_wp , N ) y1 = x ** 2 - 1.0_wp y2 = x ** 3 - 1.0_wp call figure () call subplot ( 1 , 1 , 1 ) call xylim ( mixval ( x ), mixval ([ y1 , y2 ])) call fillBetween ( x , y1 , y2 , fillColor = 'c' , fillPattern = '#' , lineWidth = 2.0_wp ) call plot ( x , y1 , lineColor = 'k' , lineWidth = 3.0_wp ) call plot ( x , y2 , lineColor = 'k' , lineWidth = 3.0_wp ) call ticks ( color = 'b' , lineWidth = 3.0_wp ) call labels ( 'x' , 'y' , 'f(x)=x#u2#d-1' , color = 'r' ) end subroutine doFillBetween","tags":"","loc":"proc/dofillbetween.html","title":"doFillBetween – PlPlotLib"},{"text":"subroutine doHist() Arguments None Description Calls proc~~dohist~~CallsGraph proc~dohist doHist interface~mixval mixval proc~dohist->interface~mixval proc~ticks ticks proc~dohist->proc~ticks proc~bar bar proc~dohist->proc~bar proc~xylim xylim proc~dohist->proc~xylim proc~subplot subplot proc~dohist->proc~subplot proc~figure figure proc~dohist->proc~figure proc~bindata binData proc~dohist->proc~bindata proc~hist hist proc~dohist->proc~hist plbox plbox proc~ticks->plbox proc~bar->interface~mixval plline plline proc~bar->plline plfill plfill proc~bar->plfill plcol1 plcol1 proc~bar->plcol1 plwind plwind proc~xylim->plwind plvsta plvsta proc~subplot->plvsta plssub plssub proc~subplot->plssub plvasp plvasp proc~subplot->plvasp plvpor plvpor proc~subplot->plvpor pladv pladv proc~subplot->pladv proc~figure->plssub proc~figure->pladv pleop pleop proc~figure->pleop plbop plbop proc~figure->plbop proc~linspace linspace proc~bindata->proc~linspace proc~hist->interface~mixval proc~hist->proc~bar proc~hist->proc~bindata Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~dohist~~CalledByGraph proc~dohist doHist program~examples_prg examples_prg program~examples_prg->proc~dohist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: N = 10000 real(kind=wp), public, dimension(N,12) :: r real(kind=wp), public, dimension(N) :: x real(kind=wp), public, dimension(:,:), allocatable :: h Source Code subroutine doHist !! ![hist](|media|/example-8.svg) integer , parameter :: N = 10000 real ( wp ), dimension ( N , 12 ) :: r real ( wp ), dimension ( N ) :: x real ( wp ), dimension (:,:), allocatable :: h call random_number ( r ) x = sum ( r , 2 ) - 6.0_wp call figure () call subplot ( 1 , 2 , 1 ) call xylim ( mixval ( x ),[ 0.0_wp , 1.05_wp ]) call hist ( x , 20 ) call ticks () h = binData ( x , 20 , normalize = 2 ) call subplot ( 1 , 2 , 2 ) call xylim ( mixval ( h (:, 1 )),[ 0.0_wp , 1.05_wp * maxval ( h (:, 2 ))]) call bar ( h (:, 1 ), h (:, 2 ), c = h (:, 2 ), relWidth = 1.0_wp ) call ticks () end subroutine doHist","tags":"","loc":"proc/dohist.html","title":"doHist – PlPlotLib"},{"text":"subroutine doSurface() Arguments None Description Calls proc~~dosurface~~CallsGraph proc~dosurface doSurface proc~linspace linspace proc~dosurface->proc~linspace proc~figure figure proc~dosurface->proc~figure interface~mixval mixval proc~dosurface->interface~mixval proc~xyzlim xyzlim proc~dosurface->proc~xyzlim proc~subplot subplot proc~dosurface->proc~subplot proc~surface surface proc~dosurface->proc~surface proc~box box proc~dosurface->proc~box pladv pladv proc~figure->pladv plssub plssub proc~figure->plssub pleop pleop proc~figure->pleop plbop plbop proc~figure->plbop plw3d plw3d proc~xyzlim->plw3d plwind plwind proc~xyzlim->plwind proc~subplot->pladv proc~subplot->plssub plvsta plvsta proc~subplot->plvsta plvasp plvasp proc~subplot->plvasp plvpor plvpor proc~subplot->plvpor proc~surface->proc~linspace plsurf3d plsurf3d proc~surface->plsurf3d plbox3 plbox3 proc~box->plbox3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~dosurface~~CalledByGraph proc~dosurface doSurface program~examples_prg examples_prg program~examples_prg->proc~dosurface Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: N = 24 real(kind=wp), public, dimension(N) :: x real(kind=wp), public, dimension(N) :: y real(kind=wp), public, dimension(N,N) :: z integer, public :: i integer, public :: j Source Code subroutine doSurface !! ![surface](|media|/example-9.svg) integer , parameter :: N = 24 real ( wp ), dimension ( N ) :: x , y real ( wp ), dimension ( N , N ) :: z integer :: i , j x = linspace ( - 1 0.0_wp , 1 0.0_wp , N ) y = linspace ( - 1 0.0_wp , 1 0.0_wp , N ) forall ( i = 1 : N , j = 1 : N ) z ( i , j ) = sin ( sqrt ( x ( i ) ** 2 + y ( j ) ** 2 ) ) / sqrt ( x ( i ) ** 2 + y ( j ) ** 2 ) end forall call figure () call subplot ( 1 , 1 , 1 , is3d = . true .) call xyzlim ( mixval ( x ), mixval ( y ), mixval ( z ), zoom = 1.1_wp ) call surface ( x , y , z , 11 ) !~ \t\tcall wireframe(x,y,z,lineColor='k') call box ( 'x' , 'y' , 'z' ) end subroutine doSurface","tags":"","loc":"proc/dosurface.html","title":"doSurface – PlPlotLib"},{"text":"subroutine doError() Arguments None Description Calls proc~~doerror~~CallsGraph proc~doerror doError proc~linspace linspace proc~doerror->proc~linspace proc~errorbar errorbar proc~doerror->proc~errorbar interface~mixval mixval proc~doerror->interface~mixval proc~ticks ticks proc~doerror->proc~ticks proc~plot plot proc~doerror->proc~plot proc~xylim xylim proc~doerror->proc~xylim proc~subplot subplot proc~doerror->proc~subplot proc~figure figure proc~doerror->proc~figure proc~labels labels proc~doerror->proc~labels plerrx plerrx proc~errorbar->plerrx plerry plerry proc~errorbar->plerry plbox plbox proc~ticks->plbox plptex plptex proc~plot->plptex plline plline proc~plot->plline plssym plssym proc~plot->plssym plwind plwind proc~xylim->plwind plvsta plvsta proc~subplot->plvsta plssub plssub proc~subplot->plssub plvasp plvasp proc~subplot->plvasp plvpor plvpor proc~subplot->plvpor pladv pladv proc~subplot->pladv proc~figure->plssub proc~figure->pladv pleop pleop proc~figure->pleop plbop plbop proc~figure->plbop pllab pllab proc~labels->pllab Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~doerror~~CalledByGraph proc~doerror doError program~examples_prg examples_prg program~examples_prg->proc~doerror Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: N = 25 real(kind=wp), public, dimension(N) :: x real(kind=wp), public, dimension(N) :: y real(kind=wp), public, dimension(N) :: xe real(kind=wp), public, dimension(N) :: ye real(kind=wp), public, dimension(12) :: r real(kind=wp), public :: m real(kind=wp), public :: s integer, public :: k Source Code subroutine doError !! ![error](|media|/example-10.svg) integer , parameter :: N = 25 real ( wp ), dimension ( N ) :: x , y , xe , ye real ( wp ), dimension ( 12 ) :: r real ( wp ) :: m , s integer :: k x = linspace ( 0.0_wp , 5.0_wp , N ) y = 1.0_wp / ( x ** 2 + 1.0_wp ) do k = 1 , N call random_number ( r ) r = 0.25_wp * ( 2.0_wp * r - 1.0_wp ) m = sum ( r ) / real ( size ( r )) s = sqrt ( sum (( r - m ) ** 2 ) / real ( size ( r ) - 1 )) x ( k ) = x ( k ) + m xe ( k ) = s call random_number ( r ) r = 0.15_wp * ( 2.0_wp * r - 1.0_wp ) m = sum ( r ) / real ( size ( r )) s = sqrt ( sum (( r - m ) ** 2 ) / real ( size ( r ) - 1 )) y ( k ) = y ( k ) + m ye ( k ) = s end do call figure () call subplot ( 1 , 1 , 1 ) call xylim ( mixval ([ x - xe , x + xe ]) + [ - 0.5_wp , 0.5_wp ], mixval ([ y - ye , y + ye ]) + [ - 0.2_wp , 0.2_wp ]) call errorbar ( x , y , xerr = xe , yerr = ye , lineColor = 'b' , lineWidth = 1.0_wp ) call plot ( x , y , lineStyle = '' , markStyle = 's' , markColor = 'r' , markSize = 1.5_wp ) call ticks () call labels ( 'x' , 'y' , '' ) end subroutine doError","tags":"","loc":"proc/doerror.html","title":"doError – PlPlotLib"},{"text":"subroutine doLogPlot() Arguments None Description Calls proc~~dologplot~~CallsGraph proc~dologplot doLogPlot proc~linspace linspace proc~dologplot->proc~linspace interface~mixval mixval proc~dologplot->interface~mixval proc~ticks ticks proc~dologplot->proc~ticks proc~plot plot proc~dologplot->proc~plot proc~xylim xylim proc~dologplot->proc~xylim proc~subplot subplot proc~dologplot->proc~subplot proc~figure figure proc~dologplot->proc~figure proc~labels labels proc~dologplot->proc~labels plbox plbox proc~ticks->plbox plptex plptex proc~plot->plptex plline plline proc~plot->plline plssym plssym proc~plot->plssym plwind plwind proc~xylim->plwind plvsta plvsta proc~subplot->plvsta plssub plssub proc~subplot->plssub plvasp plvasp proc~subplot->plvasp plvpor plvpor proc~subplot->plvpor pladv pladv proc~subplot->pladv proc~figure->plssub proc~figure->pladv pleop pleop proc~figure->pleop plbop plbop proc~figure->plbop pllab pllab proc~labels->pllab Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~dologplot~~CalledByGraph proc~dologplot doLogPlot program~examples_prg examples_prg program~examples_prg->proc~dologplot Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: N = 25 real(kind=wp), public, dimension(N) :: x real(kind=wp), public, dimension(N) :: y real(kind=wp), public, dimension(N) :: yl Source Code subroutine doLogPlot !! ![logPlot](|media|/example-11.svg) integer , parameter :: N = 25 real ( wp ), dimension ( N ) :: x , y , yl x = linspace ( 0.0_wp , 5.0_wp , N ) y = exp ( - x ** 2 ) yl = log10 ( y ) call figure () call subplot ( 1 , 1 , 1 ) call xylim ( mixval ( x ), mixval ( yl )) call plot ( x , yl , lineColor = 'r' , lineWidth = 2.0_wp ) call ticks ( logy = . true .) call labels ( 'x [linear]' , 'y [log]' , 'exp(-x#u2#d)' ) end subroutine doLogPlot","tags":"","loc":"proc/dologplot.html","title":"doLogPlot – PlPlotLib"},{"text":"purefunction f(x, t) result(o) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: t Return Value real(kind=wp) Called By proc~~f~~CalledByGraph proc~f f program~animate_prg animate_prg program~animate_prg->proc~f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function f ( x , t ) result ( o ) real ( wp ), intent ( in ) :: x , t real ( wp ) :: o o = sin ( t ) * cos ( x + t ) end function f","tags":"","loc":"proc/f.html","title":"f – PlPlotLib"},{"text":"Uses: iso_fortran_env kinds_mod module~~utilities_mod~~UsesGraph module~utilities_mod utilities_mod module~kinds_mod kinds_mod module~kinds_mod->module~utilities_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~utilities_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Utility module containing miscellaneous tools that don't\n quite fit anywhere else. Used By module~~utilities_mod~~UsedByGraph module~utilities_mod utilities_mod module~plplotlib_mod plplotlib_mod module~utilities_mod->module~plplotlib_mod program~animate_prg animate_prg module~utilities_mod->program~animate_prg program~basic_prg basic_prg module~utilities_mod->program~basic_prg program~logo_prg logo_prg module~utilities_mod->program~logo_prg module~plplotlib_mod->program~animate_prg module~plplotlib_mod->program~basic_prg module~plplotlib_mod->program~logo_prg program~examples_prg examples_prg module~plplotlib_mod->program~examples_prg Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: stdin = INPUT_UNIT integer, public, parameter :: stdout = OUTPUT_UNIT Interfaces public interface mixval Return a 2-vector comprising the minimum and maximum values of an array private function mixval_1(x) result(b) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Array to find extrema in Return Value real(kind=wp),\n  dimension(2) Description Return [hi,low] for an array private function mixval_2(x) result(b) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: x Array to find extrema in Return Value real(kind=wp),\n  dimension(2) Description Return [hi,low] for an array private function mixval_3(x) result(b) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: x Array to find extrema in Return Value real(kind=wp),\n  dimension(2) Description Return [hi,low] for an array public interface span Return a the maximum-minumum values of an array private function span_1(x) result(o) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Array to find span in Return Value real(kind=wp) Description Return hi-low for an array private function span_2(x) result(o) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: x Array to find span in Return Value real(kind=wp) Description Return hi-low for an array private function span_3(x) result(o) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: x Array to find span in Return Value real(kind=wp) Description Return hi-low for an array public interface flatten Reduce an array to one dimension private function flatten_2(A) result(o) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: A Array to convert Return Value real(kind=wp),\n  dimension(:),allocatable Description Convert a 2d array to 1d private function flatten_3(A) result(o) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:,:) :: A Array to convert Return Value real(kind=wp),\n  dimension(:),allocatable Description Convert a 3d array to 1d Functions public function linspace (l, h, N) result(o) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: l Low-bound for values real(kind=wp), intent(in) :: h High-bound for values integer, intent(in), optional :: N Number of values (default 20) Return Value real(kind=wp),\n  dimension(:),allocatable Description Return an array of evenly-spaced values public function startsWith (text, str) result(o) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: text Text to search character(len=*), intent(in) :: str String to look for Return Value logical Description Test if text starts with str public function endsWith (text, str) result(o) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: text Text to search character(len=*), intent(in) :: str String to look for Return Value logical Description Test if text ends with str public function randomNormal () result(o) Arguments None Return Value real(kind=wp) Description Return a sample from an approximate normal distribution\n with a mean of \\mu=0 and a standard deviation of\n \\sigma=1. In this approximate distribution, x\\in[-6,6]. public function randomUniform () result(o) Arguments None Return Value real(kind=wp) Description Return a sample from a uniform distribution\n in the range x\\in[-1,1]. public function meshGridX (x, y) result(o) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x x-positions in grid real(kind=wp), intent(in), dimension(:) :: y y-positions in grid Return Value real(kind=wp),\n  dimension(:,:),allocatable Description Construct a 2d array of X values from a structured grid public function meshGridY (x, y) result(o) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x x-positions in grid real(kind=wp), intent(in), dimension(:) :: y y-positions in grid Return Value real(kind=wp),\n  dimension(:,:),allocatable Description Construct a 2d array of Y values from a structured grid public function colorize (s, c) result(o) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String to colorize integer, , dimension(3) :: c Color code in [r,g,b] where r,g,b\\in[0,5] Return Value character(len=:),\n  allocatable Description Add terminal format codes to coloize a string public elementalfunction real2char (a, f, l) result(o) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a Real value to convert character(len=*), intent(in), optional :: f Format of result integer, intent(in), optional :: l Length of result Return Value character(len=:),\n  allocatable Description Convert a real to a character public elementalfunction int2char (a, f, l) result(o) Arguments Type Intent Optional Attributes Name integer, intent(in) :: a Integer value to convert character(len=*), intent(in), optional :: f Format of result integer, intent(in), optional :: l Length of result Return Value character(len=:),\n  allocatable Description Convert an integer to a character public function mean (d) result(o) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: d Return Value real(kind=wp) Description Compute the arithmetic mean of an array public function stdev (d) result(o) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: d Return Value real(kind=wp) Description Compute the standard deviation of an array Subroutines public subroutine showProgress (m, p) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: m Message to show real(kind=wp), intent(in) :: p Progress level p\\in[0,1] Description Show a progress bar with a message","tags":"","loc":"module/utilities_mod.html","title":"utilities_mod – PlPlotLib"},{"text":"Uses: kinds_mod plplot utilities_mod module~~plplotlib_mod~~UsesGraph module~plplotlib_mod plplotlib_mod module~utilities_mod utilities_mod module~utilities_mod->module~plplotlib_mod module~kinds_mod kinds_mod module~kinds_mod->module~plplotlib_mod module~kinds_mod->module~utilities_mod plplot plplot plplot->module~plplotlib_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~utilities_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Wrapper module for plplot to give it a more matplotlib like personality Used By module~~plplotlib_mod~~UsedByGraph module~plplotlib_mod plplotlib_mod program~logo_prg logo_prg module~plplotlib_mod->program~logo_prg program~animate_prg animate_prg module~plplotlib_mod->program~animate_prg program~basic_prg basic_prg module~plplotlib_mod->program~basic_prg program~examples_prg examples_prg module~plplotlib_mod->program~examples_prg Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Functions public function binData (d, N, db, normalize) result(o) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: d Data for binning integer, intent(in), optional :: N Number of bins real(kind=wp), intent(in), optional dimension(2) :: db Boundaries of bin range integer, intent(in), optional :: normalize Normalization type (1=sum, 2=bin size, 3=maxval) Return Value real(kind=wp),\n  dimension(:,:),allocatable Description Count data in each bin Subroutines public subroutine figure () Arguments None Description Create a new figure public subroutine subplot (ny, nx, i, aspect, is3d) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ny Number of subplot rows integer, intent(in) :: nx Number of subplot columns integer, intent(in) :: i Subplot to use real(kind=wp), intent(in), optional :: aspect Aspect ratio of the axes logical, intent(in), optional :: is3d Description Create a set of axes on a figure public subroutine xylim (xb, yb) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2) :: xb x-range of plot real(kind=wp), intent(in), dimension(2) :: yb y-range of plot Description Set the x and y ranges of the plot public subroutine xlim (xl, xh) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xl real(kind=wp), intent(in) :: xh Description Set the limits of the x-axis public subroutine ylim (yl, yh) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: yl real(kind=wp), intent(in) :: yh Description Set the limits of the y-axis public subroutine xyzlim (xb, yb, zb, altitude, azimuth, zoom) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(2) :: xb x-range of plot real(kind=wp), intent(in), dimension(2) :: yb y-range of plot real(kind=wp), intent(in), dimension(2) :: zb z-range of plot real(kind=wp), intent(in), optional :: altitude Altitude angle of plot in degrees real(kind=wp), intent(in), optional :: azimuth Azimuth angle of plot in degrees real(kind=wp), intent(in), optional :: zoom Zoom ratio (default 1.0) Description Set the limits for a 3d plot public subroutine ticks (dx, dy, logx, logy, color, linewidth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), optional :: dx Spacing between ticks on x-axis real(kind=wp), intent(in), optional :: dy Spacing between ticks on y-axis logical, intent(in), optional :: logx Flag for log-ticks and labels on x-axis logical, intent(in), optional :: logy Flag for log-ticks and labels on y-axis character(len=*), intent(in), optional :: color Color code for ticks, box, and labels real(kind=wp) , optional :: linewidth Line width for ticks and box Description Set the ticks for the axes public subroutine box (xLabel, yLabel, zLabel, color) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: xLabel Label for x-axis character(len=*), intent(in) :: yLabel Label for x-axis character(len=*), intent(in) :: zLabel Label for z-axis character(len=*), intent(in), optional :: color Color of labels Description Set x,y and plot labels public subroutine xticks (d, logScale, primary, secondary, color, linewidth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), optional :: d Spacing between ticks logical, intent(in), optional :: logScale Flag for log-ticks and labels logical, intent(in), optional :: primary Draw primary axis logical, intent(in), optional :: secondary Draw secondary axis character(len=*), intent(in), optional :: color Color code for ticks, box, and labels real(kind=wp) , optional :: linewidth Line width for ticks and box Description Set the ticks for the x-axis public subroutine yticks (d, logScale, primary, secondary, color, linewidth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), optional :: d Spacing between ticks logical, intent(in), optional :: logScale Flag for log-ticks and labels logical, intent(in), optional :: primary Draw primary axis logical, intent(in), optional :: secondary Draw secondary axis character(len=*), intent(in), optional :: color Color code for ticks, box, and labels real(kind=wp) , optional :: linewidth Line width for ticks and box Description Set the ticks for the y-axis public subroutine labels (xLabel, yLabel, plotLabel, color) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: xLabel Label for x-axis character(len=*), intent(in) :: yLabel Label for x-axis character(len=*), intent(in) :: plotLabel Label entire plot character(len=*), intent(in), optional :: color Color of labels Description Set x,y and plot labels public subroutine xlabel (label, color) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label Label for axis character(len=*), intent(in), optional :: color Color of labels Description Set x-label public subroutine ylabel (label, color) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label Label for axis character(len=*), intent(in), optional :: color Color of labels Description Set y-label public subroutine title (label, color) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label Label for plot character(len=*), intent(in), optional :: color Color of labels Description Set plot title public subroutine colorbar (z, N, leftLabel, rightLabel) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: z Data used for levels computation integer, intent(in) :: N Number of levels to compute character(len=*), intent(in), optional :: leftLabel Label for left side of colorbar character(len=*), intent(in), optional :: rightLabel Label for right side of colorbar Description Add a colorbar to the top of the plot public subroutine colorbar2 (z, N, leftLabel, rightLabel) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: z Data used for levels computation integer, intent(in) :: N Number of levels to compute character(len=*), intent(in), optional :: leftLabel Label for left side of colorbar character(len=*), intent(in), optional :: rightLabel Label for right side of colorbar Description Add a colorbar to the top of the plot public subroutine legend (corner, series, lineWidths, markScales, markCounts, ncol) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: corner Corner for legend character(len=*), intent(in), dimension(:,:) :: series Data series in rows\n [name,textColor,lineStyle,lineColor,markStyle,markColor,boxColor] real(kind=wp), intent(in), optional dimension(:) :: lineWidths Line widths for the plots real(kind=wp), intent(in), optional dimension(:) :: markScales Marker sizes for the plots integer, intent(in), optional dimension(:) :: markCounts Marker counts for the plots integer, intent(in), optional :: ncol Number of columns Description Create legend for plot data public subroutine hist (d, N, db, relWidth, fillColor, fillPattern, lineColor, lineWidth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: d Data for binning integer, intent(in), optional :: N Number of bins real(kind=wp), intent(in), optional dimension(2) :: db Boundaries of bin range real(kind=wp), intent(in), optional :: relWidth Relative width of bars (default 0.8) character(len=*), intent(in), optional :: fillColor Color of bar fills character(len=*), intent(in), optional :: fillPattern Pattern of bar fills character(len=*), intent(in), optional :: lineColor Color of lines around bars real(kind=wp) , optional :: lineWidth Width of lines around bars Description Create a histogram public subroutine scatter (x, y, c, s, markColor, markStyle, markSize) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x x-coordinates of data real(kind=wp), intent(in), dimension(:) :: y y-coordinates of data real(kind=wp), intent(in), optional dimension(:) :: c Data for smooth coloring real(kind=wp), intent(in), optional dimension(:) :: s Data for marker scaling character(len=*), intent(in), optional :: markColor Color of markers; overridden by z character(len=*), intent(in), optional :: markStyle Style of markers real(kind=wp), intent(in), optional :: markSize Size of markers Description Create scatter plot of data public subroutine plot (x, y, lineColor, lineStyle, lineWidth, markColor, markStyle, markSize) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x x-data for plot real(kind=wp), intent(in), dimension(:) :: y y-data for plot character(len=*), intent(in), optional :: lineColor Color of line character(len=*), intent(in), optional :: lineStyle Style of line; '' for no line real(kind=wp), intent(in), optional :: lineWidth Width of line character(len=*), intent(in), optional :: markColor Color of markers, if any character(len=*), intent(in), optional :: markStyle Style of markers; '' or absent for none real(kind=wp), intent(in), optional :: markSize Size of markers, if any Description Plot data using lines and or markers public subroutine plot3 (x, y, z, lineColor, lineStyle, lineWidth, markColor, markStyle, markSize) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x x-data for plot real(kind=wp), intent(in), dimension(:) :: y y-data for plot real(kind=wp), intent(in), dimension(:) :: z z-data for plot character(len=*), intent(in), optional :: lineColor Color of line character(len=*), intent(in), optional :: lineStyle Style of line; '' for no line real(kind=wp), intent(in), optional :: lineWidth Width of line character(len=*), intent(in), optional :: markColor Color of markers, if any character(len=*), intent(in), optional :: markStyle Style of markers; '' or absent for none real(kind=wp), intent(in), optional :: markSize Size of markers, if any Description Plot data using lines and or markers public subroutine contour (x, y, z, N, lineColor, lineStyle, lineWidth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x x-coordinates of data real(kind=wp), intent(in), dimension(:) :: y y-coordinates of data real(kind=wp), intent(in), dimension(:,:) :: z Data for contouring integer, intent(in), optional :: N Number of levels to use in contour character(len=*), intent(in), optional :: lineColor Color of contour lines character(len=*), intent(in), optional :: lineStyle Style of contour lines real(kind=wp) , optional :: lineWidth Width of contour lines Description Plot contour lines public subroutine surface (x, y, z, N, lineStyle) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x x-coordinates of data real(kind=wp), intent(in), dimension(:) :: y y-coordinates of data real(kind=wp), intent(in), dimension(:,:) :: z Data for contouring integer, intent(in), optional :: N Number of levels to use in surface colors character(len=*), intent(in), optional :: lineStyle Style for xy lines ( '-' = on, '' = off ) Description Plot a 3d surface public subroutine wireframe (x, y, z, lineColor) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x x-coordinates of data real(kind=wp), intent(in), dimension(:) :: y y-coordinates of data real(kind=wp), intent(in), dimension(:,:) :: z Data for contouring character(len=*), intent(in), optional :: lineColor Color of contour lines Description Plot a 3d wireframe public subroutine contourf (x, y, z, N) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x x-coordinates of data real(kind=wp), intent(in), dimension(:) :: y y-coordinates of data real(kind=wp), intent(in), dimension(:,:) :: z Data for contouring integer, intent(in), optional :: N Number of levels to use in contour Description Plot filled contours public subroutine quiver (x, y, u, v, s, c, scaling, lineColor, lineStyle, lineWidth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x x-positions of vectors real(kind=wp), intent(in), dimension(:) :: y y-positions of vectors real(kind=wp), intent(in), dimension(:,:) :: u u-components of vectors real(kind=wp), intent(in), dimension(:,:) :: v v-components of vectors real(kind=wp), intent(in), optional dimension(:,:) :: s Scale of vectors real(kind=wp), intent(in), optional dimension(:,:) :: c Color values for vectors real(kind=wp), intent(in), optional :: scaling Scaling of vectors\n < 0 = Automatic, then scaled\n   0 = Automatic character(len=*), intent(in), optional :: lineColor Color of vectors character(len=*), intent(in), optional :: lineStyle Style of vectors' lines real(kind=wp) , optional :: lineWidth Width of vectors' lines Description Plot vectors public subroutine bar (x, y, c, relWidth, fillColor, fillPattern, lineColor, lineWidth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x x-positions of the bars' centers real(kind=wp), intent(in), dimension(:) :: y y-positions of the bars' tops real(kind=wp), intent(in), optional dimension(:) :: c Color scale for bars real(kind=wp), intent(in), optional :: relWidth Relative width of bars (default 0.8) character(len=*), intent(in), optional :: fillColor Color of bar fills character(len=*), intent(in), optional :: fillPattern Pattern of bar fills character(len=*), intent(in), optional :: lineColor Color of lines around bars real(kind=wp) , optional :: lineWidth Width of lines around bars Description Create a bar graph public subroutine barh (y, x, c, relWidth, fillColor, fillPattern, lineColor, lineWidth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: y y-positions of the bars' centers real(kind=wp), intent(in), dimension(:) :: x x-positions of the bars' tops real(kind=wp), intent(in), optional dimension(:) :: c Color scale for bars real(kind=wp), intent(in), optional :: relWidth Relative width of bars character(len=*), intent(in), optional :: fillColor Color of bar fills character(len=*), intent(in), optional :: fillPattern Pattern of bar fills character(len=*), intent(in), optional :: lineColor Color of lines around bars real(kind=wp) , optional :: lineWidth Width of lines around bars Description Create a horizontal bar graph public subroutine fillBetween (x, y1, y0, fillColor, fillPattern, lineWidth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y1 real(kind=wp), intent(in), optional dimension(:) :: y0 character(len=*), intent(in), optional :: fillColor character(len=*), intent(in), optional :: fillPattern real(kind=wp), intent(in), optional :: lineWidth Description Fill space between two lines public subroutine fillBetweenx (y, x1, x0, fillColor, fillPattern, lineWidth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: y real(kind=wp), intent(in), dimension(:) :: x1 real(kind=wp), intent(in), optional dimension(:) :: x0 character(len=*), intent(in), optional :: fillColor character(len=*), intent(in), optional :: fillPattern real(kind=wp), intent(in), optional :: lineWidth Description Fill space between two lines public subroutine errorbar (x, y, xerr, yerr, lineColor, lineStyle, lineWidth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x x-data for plot real(kind=wp), intent(in), dimension(:) :: y y-data for plot real(kind=wp), intent(in), optional dimension(:) :: xerr x-data error for plot real(kind=wp), intent(in), optional dimension(:) :: yerr y-data error for plot character(len=*), intent(in), optional :: lineColor Color of line character(len=*), intent(in), optional :: lineStyle Style of line; '' for no line real(kind=wp), intent(in), optional :: lineWidth Width of line Description Plot error bars for a set of data points public subroutine setup (device, fileName, fontScaling, whiteOnBlack, transparent, colormap, figSize) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: device Output device to use character(len=*), intent(in), optional :: fileName Name of file(s) to write to real(kind=wp), intent(in), optional :: fontScaling Font scaling relative to default value logical, intent(in), optional :: whiteOnBlack Default foreground and background colors logical, intent(in), optional :: transparent Transparent background character(len=*), intent(in), optional :: colormap Colormap to use integer, intent(in), optional dimension(2) :: figSize Size of figures to produce in pixels Description Setup PlPlot library, optionally overriding defaults public subroutine show () Arguments None Description Show the plots end finialize the PlPlot library","tags":"","loc":"module/plplotlib_mod.html","title":"plplotlib_mod – PlPlotLib"},{"text":"Module to manage kinds for the program Used By module~~kinds_mod~~UsedByGraph module~kinds_mod kinds_mod program~animate_prg animate_prg module~kinds_mod->program~animate_prg program~basic_prg basic_prg module~kinds_mod->program~basic_prg module~plplotlib_mod plplotlib_mod module~kinds_mod->module~plplotlib_mod module~utilities_mod utilities_mod module~kinds_mod->module~utilities_mod program~logo_prg logo_prg module~kinds_mod->program~logo_prg program~examples_prg examples_prg module~kinds_mod->program~examples_prg module~plplotlib_mod->program~animate_prg module~plplotlib_mod->program~basic_prg module~plplotlib_mod->program~logo_prg module~plplotlib_mod->program~examples_prg module~utilities_mod->program~animate_prg module~utilities_mod->program~basic_prg module~utilities_mod->module~plplotlib_mod module~utilities_mod->program~logo_prg Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: wp = ep Set working precision to double real(kind=wp), public, parameter :: PI = 4.0_wp*atan(1.0_wp) Archimedes' constant real(kind=wp), public, parameter :: E = exp(1.0_wp) Euler's constant Subroutines public subroutine printTypes () Arguments None Description Print the integer kinds for each real type","tags":"","loc":"module/kinds_mod.html","title":"kinds_mod – PlPlotLib"},{"text":"Uses: kinds_mod utilities_mod plplotlib_mod program~~basic_prg~~UsesGraph program~basic_prg basic_prg module~plplotlib_mod plplotlib_mod module~plplotlib_mod->program~basic_prg module~kinds_mod kinds_mod module~kinds_mod->program~basic_prg module~kinds_mod->module~plplotlib_mod module~utilities_mod utilities_mod module~kinds_mod->module~utilities_mod module~utilities_mod->program~basic_prg module~utilities_mod->module~plplotlib_mod plplot plplot plplot->module~plplotlib_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~utilities_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Create a basic plot Calls program~~basic_prg~~CallsGraph program~basic_prg basic_prg proc~linspace linspace program~basic_prg->proc~linspace proc~show show program~basic_prg->proc~show interface~mixval mixval program~basic_prg->interface~mixval proc~ticks ticks program~basic_prg->proc~ticks proc~plot plot program~basic_prg->proc~plot proc~xylim xylim program~basic_prg->proc~xylim proc~subplot subplot program~basic_prg->proc~subplot proc~figure figure program~basic_prg->proc~figure proc~setup setup program~basic_prg->proc~setup proc~labels labels program~basic_prg->proc~labels plend plend proc~show->plend plbox plbox proc~ticks->plbox plptex plptex proc~plot->plptex plline plline proc~plot->plline plssym plssym proc~plot->plssym plwind plwind proc~xylim->plwind plvsta plvsta proc~subplot->plvsta plssub plssub proc~subplot->plssub plvasp plvasp proc~subplot->plvasp plvpor plvpor proc~subplot->plvpor pladv pladv proc~subplot->pladv proc~figure->plssub proc~figure->pladv pleop pleop proc~figure->pleop plbop plbop proc~figure->plbop plinit plinit proc~setup->plinit plsdev plsdev proc~setup->plsdev plsfam plsfam proc~setup->plsfam plsfnam plsfnam proc~setup->plsfnam plfontld plfontld proc~setup->plfontld plsetopt plsetopt proc~setup->plsetopt pllab pllab proc~labels->pllab Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial real(kind=wp), dimension(:), allocatable :: x real(kind=wp), dimension(:), allocatable :: y Source Code program basic_prg !! Create a basic plot !! !! ![plot](|media|/basic-1.svg) use kinds_mod use utilities_mod use plplotlib_mod implicit none real ( wp ), dimension (:), allocatable :: x , y x = linspace ( - 2.0_wp , 2.0_wp , 101 ) y = x ** 2 - 1.0_wp call setup ( device = 'svgqt' , fileName = 'examples/basic-%n.svg' , figSize = [ 400 , 300 ]) call figure () call subplot ( 1 , 1 , 1 ) call xylim ( mixval ( x ), mixval ( y )) call plot ( x , y , lineColor = 'r' , lineWidth = 2.0_wp ) call ticks () call labels ( '#fix#fn' , '#fiy#fn' , 'Plot' ) call show () end program basic_prg","tags":"","loc":"program/basic_prg.html","title":"basic_prg – PlPlotLib"},{"text":"Uses: kinds_mod utilities_mod plplotlib_mod program~~logo_prg~~UsesGraph program~logo_prg logo_prg module~plplotlib_mod plplotlib_mod module~plplotlib_mod->program~logo_prg module~kinds_mod kinds_mod module~kinds_mod->program~logo_prg module~kinds_mod->module~plplotlib_mod module~utilities_mod utilities_mod module~kinds_mod->module~utilities_mod module~utilities_mod->program~logo_prg module~utilities_mod->module~plplotlib_mod plplot plplot plplot->module~plplotlib_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~utilities_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Create the project logo Calls program~~logo_prg~~CallsGraph program~logo_prg logo_prg proc~setup setup program~logo_prg->proc~setup proc~show show program~logo_prg->proc~show proc~makelogo makeLogo program~logo_prg->proc~makelogo plinit plinit proc~setup->plinit plsdev plsdev proc~setup->plsdev plsfam plsfam proc~setup->plsfam plsfnam plsfnam proc~setup->plsfnam plfontld plfontld proc~setup->plfontld plsetopt plsetopt proc~setup->plsetopt plend plend proc~show->plend proc~linspace linspace proc~makelogo->proc~linspace interface~mixval mixval proc~makelogo->interface~mixval proc~ticks ticks proc~makelogo->proc~ticks proc~plot plot proc~makelogo->proc~plot proc~xylim xylim proc~makelogo->proc~xylim proc~subplot subplot proc~makelogo->proc~subplot proc~figure figure proc~makelogo->proc~figure proc~labels labels proc~makelogo->proc~labels plbox plbox proc~ticks->plbox plptex plptex proc~plot->plptex plline plline proc~plot->plline plssym plssym proc~plot->plssym plwind plwind proc~xylim->plwind plvsta plvsta proc~subplot->plvsta plssub plssub proc~subplot->plssub plvasp plvasp proc~subplot->plvasp plvpor plvpor proc~subplot->plvpor pladv pladv proc~subplot->pladv proc~figure->plssub proc~figure->pladv pleop pleop proc~figure->pleop plbop plbop proc~figure->plbop pllab pllab proc~labels->pllab Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Subroutines subroutine makeLogo () Arguments None Source Code program logo_prg !! Create the project logo use kinds_mod use utilities_mod use plplotlib_mod implicit none call setup ( device = 'svgqt' , fileName = 'logo-%n.png' , figSize = [ 128 , 128 ]) call makeLogo call show () contains subroutine makeLogo real ( wp ), dimension (:), allocatable :: x , y1 , y2 , y3 x = linspace ( 0.0_wp , 1.0_wp , 100 ) y1 = x ** 2 - 1.0_wp y2 = 2.0_wp * x - 1.0_wp y3 = x y3 = cos ( 2.0_wp * PI * x ) call figure () call subplot ( 1 , 1 , 1 ) call xylim ( mixval ( x ), mixval ([ y1 , y2 , y3 ]) * 1.1_wp ) call plot ( x , y1 , lineColor = 'b' , lineWidth = 1 0.0_wp ) call plot ( x , y2 , lineColor = 'r' , lineWidth = 1 0.0_wp ) call plot ( x , y3 , lineColor = 'c' , lineWidth = 1 0.0_wp ) call ticks ( lineWidth = 5.0_wp ) call labels ( '' , '' , '' ) end subroutine makeLogo end program logo_prg","tags":"","loc":"program/logo_prg.html","title":"logo_prg – PlPlotLib"},{"text":"Uses: kinds_mod plplotlib_mod program~~examples_prg~~UsesGraph program~examples_prg examples_prg module~kinds_mod kinds_mod module~kinds_mod->program~examples_prg module~plplotlib_mod plplotlib_mod module~kinds_mod->module~plplotlib_mod module~utilities_mod utilities_mod module~kinds_mod->module~utilities_mod module~plplotlib_mod->program~examples_prg module~utilities_mod->module~plplotlib_mod plplot plplot plplot->module~plplotlib_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~utilities_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A collection of example plots Calls program~~examples_prg~~CallsGraph program~examples_prg examples_prg proc~dofillbetween doFillBetween program~examples_prg->proc~dofillbetween proc~dologplot doLogPlot program~examples_prg->proc~dologplot proc~show show program~examples_prg->proc~show proc~docontour doContour program~examples_prg->proc~docontour proc~dohist doHist program~examples_prg->proc~dohist proc~dolegend doLegend program~examples_prg->proc~dolegend proc~dobar doBar program~examples_prg->proc~dobar proc~doerror doError program~examples_prg->proc~doerror proc~doquiver doQuiver program~examples_prg->proc~doquiver proc~doplot doPlot program~examples_prg->proc~doplot proc~setup setup program~examples_prg->proc~setup proc~doscatter doScatter program~examples_prg->proc~doscatter proc~dosurface doSurface program~examples_prg->proc~dosurface proc~linspace linspace proc~dofillbetween->proc~linspace interface~mixval mixval proc~dofillbetween->interface~mixval proc~ticks ticks proc~dofillbetween->proc~ticks proc~fillbetween fillBetween proc~dofillbetween->proc~fillbetween proc~plot plot proc~dofillbetween->proc~plot proc~xylim xylim proc~dofillbetween->proc~xylim proc~subplot subplot proc~dofillbetween->proc~subplot proc~figure figure proc~dofillbetween->proc~figure proc~labels labels proc~dofillbetween->proc~labels proc~dologplot->proc~linspace proc~dologplot->interface~mixval proc~dologplot->proc~ticks proc~dologplot->proc~plot proc~dologplot->proc~xylim proc~dologplot->proc~subplot proc~dologplot->proc~figure proc~dologplot->proc~labels plend plend proc~show->plend proc~docontour->proc~linspace proc~docontour->interface~mixval proc~docontour->proc~ticks proc~docontour->proc~xylim proc~docontour->proc~subplot proc~docontour->proc~figure proc~docontour->proc~labels proc~contour contour proc~docontour->proc~contour proc~contourf contourf proc~docontour->proc~contourf proc~colorbar colorbar proc~docontour->proc~colorbar proc~dohist->interface~mixval proc~dohist->proc~ticks proc~dohist->proc~xylim proc~dohist->proc~subplot proc~dohist->proc~figure proc~bar bar proc~dohist->proc~bar proc~bindata binData proc~dohist->proc~bindata proc~hist hist proc~dohist->proc~hist proc~dolegend->proc~linspace proc~dolegend->interface~mixval proc~dolegend->proc~ticks proc~dolegend->proc~plot proc~dolegend->proc~xylim proc~dolegend->proc~subplot proc~dolegend->proc~figure proc~dolegend->proc~labels proc~legend legend proc~dolegend->proc~legend proc~dobar->proc~linspace proc~dobar->interface~mixval proc~dobar->proc~ticks proc~dobar->proc~xylim proc~dobar->proc~subplot proc~dobar->proc~figure proc~dobar->proc~labels proc~dobar->proc~bar proc~barh barh proc~dobar->proc~barh proc~doerror->proc~linspace proc~doerror->interface~mixval proc~doerror->proc~ticks proc~doerror->proc~plot proc~doerror->proc~xylim proc~doerror->proc~subplot proc~doerror->proc~figure proc~doerror->proc~labels proc~errorbar errorbar proc~doerror->proc~errorbar proc~doquiver->proc~linspace proc~doquiver->interface~mixval proc~doquiver->proc~ticks proc~doquiver->proc~xylim proc~doquiver->proc~subplot proc~doquiver->proc~figure proc~doquiver->proc~labels proc~doquiver->proc~colorbar proc~quiver quiver proc~doquiver->proc~quiver proc~doplot->proc~linspace proc~doplot->interface~mixval proc~doplot->proc~plot proc~doplot->proc~xylim proc~doplot->proc~subplot proc~doplot->proc~figure proc~ylabel ylabel proc~doplot->proc~ylabel proc~xlabel xlabel proc~doplot->proc~xlabel proc~xticks xticks proc~doplot->proc~xticks proc~yticks yticks proc~doplot->proc~yticks proc~title title proc~doplot->proc~title plinit plinit proc~setup->plinit plsdev plsdev proc~setup->plsdev plsfam plsfam proc~setup->plsfam plsfnam plsfnam proc~setup->plsfnam plfontld plfontld proc~setup->plfontld plsetopt plsetopt proc~setup->plsetopt proc~doscatter->proc~ticks proc~doscatter->proc~xylim proc~doscatter->proc~subplot proc~doscatter->proc~figure proc~doscatter->proc~labels proc~scatter scatter proc~doscatter->proc~scatter proc~dosurface->proc~linspace proc~dosurface->interface~mixval proc~dosurface->proc~subplot proc~dosurface->proc~figure proc~xyzlim xyzlim proc~dosurface->proc~xyzlim proc~surface surface proc~dosurface->proc~surface proc~box box proc~dosurface->proc~box plbox plbox proc~ticks->plbox plfill plfill proc~fillbetween->plfill plptex plptex proc~plot->plptex plline plline proc~plot->plline plssym plssym proc~plot->plssym plwind plwind proc~xylim->plwind plvsta plvsta proc~subplot->plvsta plssub plssub proc~subplot->plssub plvasp plvasp proc~subplot->plvasp plvpor plvpor proc~subplot->plvpor pladv pladv proc~subplot->pladv proc~figure->plssub proc~figure->pladv pleop pleop proc~figure->pleop plbop plbop proc~figure->plbop pllab pllab proc~labels->pllab plcont plcont proc~contour->plcont proc~contourf->proc~linspace plshades plshades proc~contourf->plshades plcolorbar plcolorbar proc~colorbar->plcolorbar proc~bar->interface~mixval proc~bar->plfill proc~bar->plline plcol1 plcol1 proc~bar->plcol1 proc~bindata->proc~linspace proc~hist->interface~mixval proc~hist->proc~bar proc~hist->proc~bindata none~doboxes doBoxes proc~legend->none~doboxes none~dolines doLines proc~legend->none~dolines none~dolegendbox doLegendBox proc~legend->none~dolegendbox none~domarkers doMarkers proc~legend->none~domarkers pllegend pllegend proc~legend->pllegend none~dotext doText proc~legend->none~dotext series series none~doboxes->series none~dolines->series none~getcorner getCorner none~dolegendbox->none~getcorner none~domarkers->series none~dotext->series proc~startswith startsWith none~getcorner->proc~startswith proc~endswith endsWith none~getcorner->proc~endswith proc~barh->interface~mixval proc~barh->plfill proc~barh->plline proc~barh->plcol1 plerrx plerrx proc~errorbar->plerrx plerry plerry proc~errorbar->plerry proc~quiver->interface~mixval proc~quiver->plcol1 plvect plvect proc~quiver->plvect plmtex plmtex proc~ylabel->plmtex proc~xlabel->plmtex proc~xticks->plbox proc~yticks->plbox proc~title->plmtex proc~scatter->interface~mixval proc~scatter->plptex proc~scatter->plssym proc~scatter->plcol1 plschr plschr proc~scatter->plschr proc~xyzlim->plwind plw3d plw3d proc~xyzlim->plw3d proc~surface->proc~linspace plsurf3d plsurf3d proc~surface->plsurf3d plbox3 plbox3 proc~box->plbox3 var panprogramexamples_prgCallsGraph = svgPanZoom('#programexamples_prgCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Subroutines subroutine doPlot () Arguments None Description subroutine doScatter () Arguments None Description subroutine doContour () Arguments None Description subroutine doLegend () Arguments None Description subroutine doQuiver () Arguments None Description subroutine doBar () Arguments None Description subroutine doFillBetween () Arguments None Description subroutine doHist () Arguments None Description subroutine doSurface () Arguments None Description subroutine doError () Arguments None Description subroutine doLogPlot () Arguments None Description Source Code program examples_prg !! A collection of example plots use kinds_mod use plplotlib_mod implicit none call setup ( device = 'svgqt' , fileName = 'examples/example-%n.svg' , figSize = [ 320 , 240 ], transparent = . true .) call doPlot () call doScatter () call doContour () call doLegend () call doQuiver () call doBar () call doFillBetween () call doHist () call doSurface () call doError () call doLogPlot () call show () contains subroutine doPlot !! ![plot](|media|/example-1.svg) integer , parameter :: N = 20 real ( wp ), dimension ( N ) :: x , y x = linspace ( 0.0_wp , 1.0_wp , N ) y = x ** 2 - 1.0_wp call figure () call subplot ( 1 , 1 , 1 ) call xylim ( mixval ( x ), mixval ( y )) call plot ( x , y , lineColor = 'red' , lineWidth = 2.0_wp , & & markStyle = '.' , markColor = 'cyan' , markSize = 2.0_wp ) call plot ( x , - 1.0_wp - y , lineColor = 'blue' , lineStyle = ':' , lineWidth = 2.0_wp , & & markStyle = '+' , markColor = 'green' , markSize = 1.0_wp ) !~ \t\tcall ticks() call xticks ( primary = . true ., secondary = . false .) call yticks ( primary = . true ., secondary = . false .) !~ \t\tcall labels('x','y','f(x)=x#u2#d-1; g(x)=-x#u2#d') call xlabel ( 'x' ) call ylabel ( 'y' ) call title ( 'f(x)=x#u2#d-1; g(x)=-x#u2#d' ) end subroutine doPlot subroutine doScatter !! ![scatter](|media|/example-2.svg) integer , parameter :: N = 100 real ( wp ), dimension ( N ) :: x , y , z call random_number ( x ) call random_number ( y ) z = sqrt ( x ** 2 + y ** 2 ) call figure () call subplot ( 2 , 2 , 1 ) call xylim ([ 0.0_wp , 1.0_wp ],[ 0.0_wp , 1.0_wp ]) call scatter ( x , y ) call ticks () call labels ( 'x' , 'y' , '' ) call subplot ( 2 , 2 , 2 ) call xylim ([ 0.0_wp , 1.0_wp ],[ 0.0_wp , 1.0_wp ]) call scatter ( x , y , c = z ) call ticks () call labels ( 'x' , 'y' , '' ) call subplot ( 2 , 2 , 3 ) call xylim ([ 0.0_wp , 1.0_wp ],[ 0.0_wp , 1.0_wp ]) call scatter ( x , y , s = ( 4.0_wp * z + 1.0_wp ), markColor = 'blue' ) call ticks () call labels ( 'x' , 'y' , '' ) call subplot ( 2 , 2 , 4 ) call xylim ([ 0.0_wp , 1.0_wp ],[ 0.0_wp , 1.0_wp ]) call scatter ( x , y , c = z , s = ( 4.0_wp * z + 1.0_wp )) call ticks () call labels ( 'x' , 'y' , '' ) end subroutine doScatter subroutine doContour !! ![contour](|media|/example-3.svg) integer , parameter :: N = 50 real ( wp ), dimension ( N ) :: x , y real ( wp ), dimension ( N , N ) :: z integer :: i , j x = linspace ( - 1 0.0_wp , 1 0.0_wp , N ) y = linspace ( - 1 0.0_wp , 1 0.0_wp , N ) forall ( i = 1 : N , j = 1 : N ) z ( i , j ) = sin ( sqrt ( x ( i ) ** 2 + y ( j ) ** 2 ) ) / sqrt ( x ( i ) ** 2 + y ( j ) ** 2 ) end forall call figure () call subplot ( 1 , 1 , 1 , aspect = 1.0_wp ) call xylim ( mixval ( x ), mixval ( y )) call contourf ( x , y , z , 10 ) call contour ( x , y , z , 10 ) call colorbar ( z , 5 ) call ticks () call labels ( 'x' , 'y' , '' ) end subroutine doContour subroutine doLegend !! ![legend](|media|/example-4.svg) integer , parameter :: N = 20 real ( wp ), dimension ( N ) :: x , y character ( 32 ), dimension ( 3 , 7 ) :: series x = linspace ( 0.0_wp , 1.0_wp , N ) y = x ** 2 - 1.0_wp call figure () call subplot ( 1 , 1 , 1 ) call xylim ( mixval ( x ), mixval ( y )) call plot ( x , y , lineColor = 'red' , lineWidth = 2.0_wp , & & markStyle = '.' , markColor = 'cyan' , markSize = 2.0_wp ) call plot ( x , - 1.0_wp - y , lineColor = 'blue' , lineStyle = ':' , lineWidth = 2.0_wp , & & markStyle = '+' , markColor = 'green' , markSize = 1.0_wp ) ! [name,textColor,lineStyle,lineColor,markStyle,markColor] series ( 1 ,:) = [ character ( 32 ) :: 'f(x)=x#u2#d-1' , '' , '-' , 'r' , '.' , 'c' , '' ] series ( 2 ,:) = [ character ( 32 ) :: 'g(x)=-x#u2#d' , '' , ':' , 'b' , '+' , 'g' , '' ] series ( 3 ,:) = [ character ( 32 ) :: 'Box' , '' , '' , '' , '' , '' , 'r' ] call legend ( 'center left' , series ) call ticks () call labels ( 'x' , 'y' , '' ) end subroutine doLegend subroutine doQuiver !! ![quiver](|media|/example-5.svg) integer , parameter :: N = 20 real ( wp ), dimension ( N ) :: x , y real ( wp ), dimension ( N , N ) :: u , v , m integer :: i , j x = linspace ( - 1 0.0_wp , 1 0.0_wp , N ) y = linspace ( - 1 0.0_wp , 1 0.0_wp , N ) forall ( i = 1 : N , j = 1 : N ) u ( i , j ) = - y ( j ) v ( i , j ) = x ( i ) m ( i , j ) = sqrt ( u ( i , j ) ** 2 + v ( i , j ) ** 2 ) end forall call figure () call subplot ( 1 , 1 , 1 , aspect = 1.0_wp ) call xylim ( mixval ( x ), mixval ( y )) call quiver ( x , y , u , v , c = m , s = m , scaling = 2.0_wp , lineWidth = 2.0_wp ) call colorbar ( m , 10 ) call ticks () call labels ( 'x' , 'y' , '' ) end subroutine doQuiver subroutine doBar !! ![bar](|media|/example-6.svg) integer , parameter :: N = 21 real ( wp ), dimension ( N ) :: x , y x = linspace ( - PI , PI , N ) y = exp ( - x ** 2 ) call figure () call subplot ( 1 , 2 , 1 ) call xylim ( mixval ( x ) + [ - 0.1_wp , 0.1_wp ], mixval ( y ) + [ 0.0_wp , 0.1_wp ]) call bar ( x , y , c = y , relWidth = 1.0_wp ) call ticks () call labels ( 'x' , 'y' , '' ) call subplot ( 1 , 2 , 2 ) call xylim ( mixval ( y ) + [ 0.0_wp , 0.1_wp ], mixval ( x ) + [ - 0.1_wp , 0.1_wp ]) call barh ( x , y , fillColor = 'r' , relWidth = 1.0_wp ) call ticks () call labels ( 'x' , 'y' , '' ) end subroutine doBar subroutine doFillBetween !! ![fillBetween](|media|/example-7.svg) integer , parameter :: N = 51 real ( wp ), dimension ( N ) :: x , y1 , y2 x = linspace ( - 3.0_wp , 3.0_wp , N ) y1 = x ** 2 - 1.0_wp y2 = x ** 3 - 1.0_wp call figure () call subplot ( 1 , 1 , 1 ) call xylim ( mixval ( x ), mixval ([ y1 , y2 ])) call fillBetween ( x , y1 , y2 , fillColor = 'c' , fillPattern = '#' , lineWidth = 2.0_wp ) call plot ( x , y1 , lineColor = 'k' , lineWidth = 3.0_wp ) call plot ( x , y2 , lineColor = 'k' , lineWidth = 3.0_wp ) call ticks ( color = 'b' , lineWidth = 3.0_wp ) call labels ( 'x' , 'y' , 'f(x)=x#u2#d-1' , color = 'r' ) end subroutine doFillBetween subroutine doHist !! ![hist](|media|/example-8.svg) integer , parameter :: N = 10000 real ( wp ), dimension ( N , 12 ) :: r real ( wp ), dimension ( N ) :: x real ( wp ), dimension (:,:), allocatable :: h call random_number ( r ) x = sum ( r , 2 ) - 6.0_wp call figure () call subplot ( 1 , 2 , 1 ) call xylim ( mixval ( x ),[ 0.0_wp , 1.05_wp ]) call hist ( x , 20 ) call ticks () h = binData ( x , 20 , normalize = 2 ) call subplot ( 1 , 2 , 2 ) call xylim ( mixval ( h (:, 1 )),[ 0.0_wp , 1.05_wp * maxval ( h (:, 2 ))]) call bar ( h (:, 1 ), h (:, 2 ), c = h (:, 2 ), relWidth = 1.0_wp ) call ticks () end subroutine doHist subroutine doSurface !! ![surface](|media|/example-9.svg) integer , parameter :: N = 24 real ( wp ), dimension ( N ) :: x , y real ( wp ), dimension ( N , N ) :: z integer :: i , j x = linspace ( - 1 0.0_wp , 1 0.0_wp , N ) y = linspace ( - 1 0.0_wp , 1 0.0_wp , N ) forall ( i = 1 : N , j = 1 : N ) z ( i , j ) = sin ( sqrt ( x ( i ) ** 2 + y ( j ) ** 2 ) ) / sqrt ( x ( i ) ** 2 + y ( j ) ** 2 ) end forall call figure () call subplot ( 1 , 1 , 1 , is3d = . true .) call xyzlim ( mixval ( x ), mixval ( y ), mixval ( z ), zoom = 1.1_wp ) call surface ( x , y , z , 11 ) !~ \t\tcall wireframe(x,y,z,lineColor='k') call box ( 'x' , 'y' , 'z' ) end subroutine doSurface subroutine doError !! ![error](|media|/example-10.svg) integer , parameter :: N = 25 real ( wp ), dimension ( N ) :: x , y , xe , ye real ( wp ), dimension ( 12 ) :: r real ( wp ) :: m , s integer :: k x = linspace ( 0.0_wp , 5.0_wp , N ) y = 1.0_wp / ( x ** 2 + 1.0_wp ) do k = 1 , N call random_number ( r ) r = 0.25_wp * ( 2.0_wp * r - 1.0_wp ) m = sum ( r ) / real ( size ( r )) s = sqrt ( sum (( r - m ) ** 2 ) / real ( size ( r ) - 1 )) x ( k ) = x ( k ) + m xe ( k ) = s call random_number ( r ) r = 0.15_wp * ( 2.0_wp * r - 1.0_wp ) m = sum ( r ) / real ( size ( r )) s = sqrt ( sum (( r - m ) ** 2 ) / real ( size ( r ) - 1 )) y ( k ) = y ( k ) + m ye ( k ) = s end do call figure () call subplot ( 1 , 1 , 1 ) call xylim ( mixval ([ x - xe , x + xe ]) + [ - 0.5_wp , 0.5_wp ], mixval ([ y - ye , y + ye ]) + [ - 0.2_wp , 0.2_wp ]) call errorbar ( x , y , xerr = xe , yerr = ye , lineColor = 'b' , lineWidth = 1.0_wp ) call plot ( x , y , lineStyle = '' , markStyle = 's' , markColor = 'r' , markSize = 1.5_wp ) call ticks () call labels ( 'x' , 'y' , '' ) end subroutine doError subroutine doLogPlot !! ![logPlot](|media|/example-11.svg) integer , parameter :: N = 25 real ( wp ), dimension ( N ) :: x , y , yl x = linspace ( 0.0_wp , 5.0_wp , N ) y = exp ( - x ** 2 ) yl = log10 ( y ) call figure () call subplot ( 1 , 1 , 1 ) call xylim ( mixval ( x ), mixval ( yl )) call plot ( x , yl , lineColor = 'r' , lineWidth = 2.0_wp ) call ticks ( logy = . true .) call labels ( 'x [linear]' , 'y [log]' , 'exp(-x#u2#d)' ) end subroutine doLogPlot end program examples_prg","tags":"","loc":"program/examples_prg.html","title":"examples_prg – PlPlotLib"},{"text":"Uses: kinds_mod utilities_mod plplotlib_mod program~~animate_prg~~UsesGraph program~animate_prg animate_prg module~plplotlib_mod plplotlib_mod module~plplotlib_mod->program~animate_prg module~kinds_mod kinds_mod module~kinds_mod->program~animate_prg module~kinds_mod->module~plplotlib_mod module~utilities_mod utilities_mod module~kinds_mod->module~utilities_mod module~utilities_mod->program~animate_prg module~utilities_mod->module~plplotlib_mod plplot plplot plplot->module~plplotlib_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~utilities_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Create a series of plots for an animation Calls program~~animate_prg~~CallsGraph program~animate_prg animate_prg proc~linspace linspace program~animate_prg->proc~linspace proc~show show program~animate_prg->proc~show proc~f f program~animate_prg->proc~f proc~figure figure program~animate_prg->proc~figure proc~ticks ticks program~animate_prg->proc~ticks proc~plot plot program~animate_prg->proc~plot proc~xylim xylim program~animate_prg->proc~xylim proc~subplot subplot program~animate_prg->proc~subplot interface~mixval mixval program~animate_prg->interface~mixval proc~setup setup program~animate_prg->proc~setup proc~labels labels program~animate_prg->proc~labels plend plend proc~show->plend pladv pladv proc~figure->pladv plssub plssub proc~figure->plssub pleop pleop proc~figure->pleop plbop plbop proc~figure->plbop plbox plbox proc~ticks->plbox plptex plptex proc~plot->plptex plline plline proc~plot->plline plssym plssym proc~plot->plssym plwind plwind proc~xylim->plwind proc~subplot->pladv proc~subplot->plssub plvsta plvsta proc~subplot->plvsta plvasp plvasp proc~subplot->plvasp plvpor plvpor proc~subplot->plvpor plinit plinit proc~setup->plinit plsdev plsdev proc~setup->plsdev plsfam plsfam proc~setup->plsfam plsfnam plsfnam proc~setup->plsfnam plfontld plfontld proc~setup->plfontld plsetopt plsetopt proc~setup->plsetopt pllab pllab proc~labels->pllab Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial real(kind=wp), dimension(:), allocatable :: x real(kind=wp), dimension(:), allocatable :: y real(kind=wp), dimension(:), allocatable :: t integer :: N integer :: M integer :: i integer :: k Functions purefunction f (x, t) result(o) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: t Return Value real(kind=wp) Source Code program animate_prg !! Create a series of plots for an animation use kinds_mod use utilities_mod use plplotlib_mod implicit none real ( wp ), dimension (:), allocatable :: x , y , t integer :: N , M , i , k N = 100 M = 1000 x = linspace ( 0.0_wp , PI , N ) t = linspace ( 0.0_wp , 1 0.0_wp , M ) call setup () do k = 1 , M y = [( f ( x ( i ), t ( k )) , i = 1 , N )] call figure () call subplot ( 1 , 1 , 1 ) call xylim ( mixval ( x ),[ - 1.1_wp , 1.1_wp ]) call plot ( x , y , lineColor = 'b' , lineWidth = 2.0_wp ) call ticks () call labels ( 'x' , 'y' , '' ) end do call show () contains pure function f ( x , t ) result ( o ) real ( wp ), intent ( in ) :: x , t real ( wp ) :: o o = sin ( t ) * cos ( x + t ) end function f end program animate_prg","tags":"","loc":"program/animate_prg.html","title":"animate_prg – PlPlotLib"},{"text":"Module Usage Plotting using PlPLotLib involves several basic steps that must be taken\nfor the process to succeed. For a single line plot, the steps taken are\nthe following: 1. Initialize the library (call setup)\n2. Create a figure (call figure)\n3. Specify the subplot (call subplot)\n4. Specify axis ranges (call xylim)\n5. Plot the data (call plot)\n6. Draw axis ticks and numeric labels (call ticks)\n7. Label the axes and subplot (call labels) The same basic process is followed for all plot types. The most common\nvariations from these step are the inclusion of more than one plot and\nthe creation of a legend to distinguish between plots. Example program basic_prg !! Create a basic plot !! !! ![plot](../media/basic-1.svg) use kinds_mod use utilities_mod use plplotlib_mod implicit none real ( wp ), dimension (:), allocatable :: x , y x = linspace ( - 2.0_wp , 2.0_wp , 101 ) y = x ** 2 - 1.0_wp call setup ( device = 'svgqt' , fileName = 'examples/basic-%n.svg' , figSize = [ 400 , 300 ]) call figure () call subplot ( 1 , 1 , 1 ) call xylim ( mixval ( x ), mixval ( y )) call plot ( x , y , lineColor = 'r' , lineWidth = 2.0_wp ) call ticks () call labels ( '#fix#fn' , '#fiy#fn' , 'Plot' ) call show () end program basic_prg Step Details Details about each step of the process are found below: setup The setup routine initializes the plplot library and must be the \nfirst call made to the module. The output device can be specified \nthrough device , while the size of the plots can be controlled through figSize . After setup, these values unfortunately cannot be changed \nduring execution of the program. Example call setup ( device = 'svgqt' , figSize = [ 800 , 600 ]) Note setup figure The figure routine creates a new figure on which to place plots. Its \nsize is defined at library setup and cannot be changed afterwards. \nThere are no options to this routine, but it must be called to setup \nthe window or file for output. Example call figure () subplot After the creation of a figure, plots must be positioned on the output \nsurface. The subplot routine handles this process by breaking the \nfigure into rows and columns and selecting a cell in which to plot. Basic usage might appear as the following: call subplot ( 2 , 3 , 1 ) The command splits the figure into two rows and three columns, as well \nas preparing the library to plot in the upper-left most of these cells. Additionally, the subplot routine can force a particular aspect ratio \nfor the plotting region, which is useful if the horizontal and vertical \naxes share the same units and should be scaled equally. Note subplot xylim A call to xylim is used to set the ranges of the plotting region. Most\noften the routine mixval is used to get the needed boundary arrays to\nspecify these ranges. The most commonly use form of this routine will appear close to the \nfollowing: real ( wp ), dimension (:), allocatable :: x , y ... call xylim ( mixval ( x ), mixval ( y )) There are two other variants of this routine which set only the horizontal\nor vertical ranges of the plot. Note xylim xlim ylim plot The basic plot routine draws a line plot in the defined plotting area \nusing the set ranges for each axis to scale the data from plot \ncoordinates to world coordinates on the output device. It requires \narrays of horizontal and vertical positions, commonly referred to as x and y . Basic usage might appear as the following: real ( wp ), dimension (:), allocatable :: x , y ... call plot ( x , y ) Note plot ticks The ticks routine is used to draw tick lines and labels on the axes, and\ncan control some aspects of this process. Basic usage requires no arguments: call ticks () Additional routines exist to control the drawing of ticks on the horizontal\nand vertical axes separately. Note ticks xticks yticks labels Labels can be added to the axes as well as the top of the plot using the labels routine. The color of the labels may also be adjusted. Example call labels ( 'x-Axis' , 'y-Axis' , 'Plot Title' ) Additional routines exist to control the drawing of labels on the horizontal\nand vertical axes, and the plot title, separately. Note labels xlabel ylabel title","tags":"","loc":"page//index.html","title":"Module Usage – PlPlotLib"},{"text":"Common Arguments A number of arguments are accepted by many routines in the PlPlotLib \nmodule due to their common applicability. To prevent duplication of \neffort, these arguments are documented here with the expectation that \nthey behave in a consistent/expected manner for each of the routines \nthat accept them. Deviations from these standard behaviors or routine-specific extensions \n(if any) can be found in the documentation for each routine. color The color of various plot components may be set using a character value,\nfor example color='red' . Acceptable values include the following: * 'k', 'black'   :: Black\n* 'w', 'white'   :: White\n* 'r', 'red'     :: Red\n* 'g', 'green'   :: Green\n* 'b', 'blue'    :: Blue\n* 'm', 'magenta' :: Magenta\n* 'y', 'yellow'  :: Yellow\n* 'c', 'cyan'    :: Cyan\n* 'fg'           :: Foreground\n* 'bg'           :: Background Additionally, the character value may contain an ascii decimal encoding of real number between zero and one.\nIn this case, the color will be taken from the continuous colormap instead\nof the discrete indexed colors. For example: color='  0.534 ' This can\neasily be automated through the use of internal files. Note box labels ticks title xlabel xticks ylabel yticks lineColor A character value noting the color to use when painting lines.\nAccepted values are the following: * 'k', 'black'   :: Black\n* 'w', 'white'   :: White\n* 'r', 'red'     :: Red\n* 'g', 'green'   :: Green\n* 'b', 'blue'    :: Blue\n* 'm', 'magenta' :: Magenta\n* 'y', 'yellow'  :: Yellow\n* 'c', 'cyan'    :: Cyan\n* 'fg'           :: Foreground\n* 'bg'           :: Background Additionally, the character value may contain an ascii decimal encoding of real number between zero and one.\nIn this case, the color will be taken from the continuous colormap instead\nof the discrete indexed colors. For example: lineColor='  0.534 ' This can\neasily be automated through the use of internal files. Note hist bar barh plot plot3 contour wireframe quiver lineStyle The style of lines can be changed through the lineStyle argument which takes\na character value. Accepted values are the following: * '-'  :: Solid line\n* '--' :: Dashed line\n* ':'  :: Dotted line Note plot plot3 contour surface quiver lineWidth The width of lines used in an operation can often be set usin the lineWidth argument, with a real number multiple of the default line width. For example, lineWidth=2.5_wp will cause lines to be two and a half times thicker than\nnormal. Note ticks xticks yticks hist plot plot3 contour quiver bar barh fillBetween fillBetweenx markColor A character value noting the color to use when painting markers or symbols.\nAccepted values are the following: * 'k', 'black'   :: Black\n* 'w', 'white'   :: White\n* 'r', 'red'     :: Red\n* 'g', 'green'   :: Green\n* 'b', 'blue'    :: Blue\n* 'm', 'magenta' :: Magenta\n* 'y', 'yellow'  :: Yellow\n* 'c', 'cyan'    :: Cyan\n* 'fg'           :: Foreground\n* 'bg'           :: Background Unlike line colors, marks cannot use the continuous colormap and are thus\nrestricted to the indexed colors. Note scatter plot plot3 markStyle * '+' :: Plus\n* 'x  :: Times\n* '*' :: Star\n* '.' :: Point\n* 's' :: Square\n* '&#94;' :: Up triangle\n* '<' :: Left triangle\n* 'v' :: Down triangle\n* '>' :: Right triangle Note scatter plot plot3 markSize The size of markers can be scaled using the markSize argument, which takes\na real value multiple of the default maker size. For example, markSize=1.5_wp will scale up the markers by 50% from the default size. Note scatter plot plot3","tags":"","loc":"page/./arguments.html","title":"Common Arguments – PlPlotLib"},{"text":"License Copyright (c) 2015, Kyle Horne\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are \nmet:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n    * Neither the name of the <organization> nor the\n      names of its contributors may be used to endorse or promote products\n      derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS \nIS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED \nTO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A \nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> \nBE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR \nBUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, \nWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR \nOTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF \nADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","tags":"","loc":"page/./license.html","title":"License – PlPlotLib"},{"text":"Character Escape Codes Escape codes can be inserted into character input to the plotting \nroutines in order to change the formatting of the text.\nThe supported codes are listed below: #u : move up to the superscript position (ended with #d) #d : move down to subscript position (ended with #u) #b : backspace (to allow overprinting) ## : number symbol #+ : toggle overline mode #- : toggle underline mode #gx : Greek letter corresponding to Roman letter x (see below) #fn : switch to normal (sans-serif) font #fr : switch to Roman (serif) font #fi : switch to italic font #fs : switch to script font When greek letters are inserted using the code '#gx', the replacements \nare made according to the following rules: = ROMAN = = GREEK = = roman = = greek = A Α a α B Β b β G Γ g γ D Δ d δ E Ε e ε Z Ζ z ζ Y Η y η H Θ h θ I Ι i ι K Κ k κ L Λ l λ M Μ m μ N Ν n ν C Ξ c ξ O Ο o ο P Π p π R Ρ r ρ S Σ s σ T Τ t τ U Υ u υ F Φ f φ X Χ x χ Q Ψ q ψ W Ω w ω One obvious application of escape codes is the formatting of axis \nlabels, where symbols are usually italic to match their usage in the \ntext of the document. Eg: call labels ( '#fix#fn' , '#fiy#fn' , '#fiy=f#d0#u(x)#fn' )","tags":"","loc":"page/./escapeCodes.html","title":"Escape Codes – PlPlotLib"}]}